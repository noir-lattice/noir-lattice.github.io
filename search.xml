<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mybatis update返回值问题</title>
      <link href="2020/12/16/mybatis-update%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/"/>
      <url>2020/12/16/mybatis-update%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对于一条下面的update返回的这个int是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeMapper</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Update</span>(<span class="string">"some update sql"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">updateById</span><span class="params">(Long id)</span></span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Orical返回的是更新影响行数（正常人都可以理解的正常逻辑语义！！！）</p><p>MySQL返回更新语句中查询命中行数（？？？？？？？？？？？？？）</p><p>如果关了更新统计，返回的是-1（？！？！？！？！？！？！）</p><p>如果你是用mysql，需要在连接属性上加上useAffectedRows才是更新影响行数（微笑😊</p>]]></content>
      
      
      <categories>
          
          <category> 踩坑记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seata与分布式事务方案</title>
      <link href="2020/12/07/Seata%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/"/>
      <url>2020/12/07/Seata%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>对于分布式事务的基础理论已经有启过一篇<a href="https://noir-lattice.github.io/2020/05/06/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">聊聊分布式事务</a>，这一篇主要将工业实践，从主流的中间件入手，掰开聊聊分布式事务框架。</p> <a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>对于大量垂直分库划分服务的微服务架构来说，和对微服务架构的第一原则相似，我们要尽量避免分布式事务。而工业上追求的最终一致性的常见方案有：</p><ul><li>TCC</li><li>SAGE</li><li>XA</li><li>MQ</li></ul><p>而Seata作为事务框架做了以上支持下还提供了AT(Automatic Transaction)模式提供选择，本文主要从AT事务展开讲解并对各类方案进行对比并对场景进行分析。</p><h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>整体架构借鉴的是DTP(Distributed Transaction Processing)模型，我们可以理解为其作为XA的设计基础，Seata将其进行了应用层的抽象实现。</p><p><img src="WX20201207-193713.png" alt="DTP-model"></p><p>既然整体模型和XA像我们为什么不使用XA呢？这里有几个问题：</p><ul><li>数据库的基础支持（Mysql5.7虽然有支持但是相当不稳定）</li><li>协议本身的问题，因为协议是数据层的，应用层无法感知，而RM中出现任何问题（超时、悬挂、死锁）应用层无法插手，优化困难且难以定位</li><li>社区支持少，落地的方案基本是商用方案（Tuxedo/WebLogic/WebSphere 等)。</li></ul><p>对于seata的DTP实现我们可以看下图：</p><p><img src="DTP%E5%AE%9E%E7%8E%B0.png" alt="seata"></p><p>我们可以看到在架构中有三个角色：</p><ul><li>TM(Transaction Manager)</li><li>RM(Resource Manager)</li><li>TC(Transaction Coordinator)</li></ul><p>TM和RM是seats-client都支持的角色，即可从任一服务发起全局事务，而xid提供了事务的统一标识，保证各服务间的事务扩散，我们来看一个事务发起的流程：</p><ol><li>TM向TC开启一个全局事务并创建生成全局唯一的xid</li><li>xid在服务链路中传播</li><li>RM在检测到链路上的xid后向TC注册分支事务并纳入全局事务管辖</li><li>TM向TC发起针对xid的全局提交或回滚</li><li>TC通过xid管辖所有分支事务进行提交或回滚</li></ol><p>而上面这个步骤不难看出，这个事务同样也是2PC甚至可以说是标准TCC的一个实现，我们再详细看具体的模式实现。</p><h2 id="AT的实现"><a href="#AT的实现" class="headerlink" title="AT的实现"></a>AT的实现</h2><p>AT是seata主创，相对于TCC对业务代码的侵入，Seata将JDBC的数据源进行代理从而通过各个服务的本地事务来进行自动的confirm or cancel。</p><p><img src="proxy.png" alt="proxy"></p><p>而通过代理数据层，可以实现所有的SQL事务的拦截与SQL的解析，从而记录下回滚日志（至undolog table）以备第二阶段的cancel使用，我们可以看看一个AT事务的生命周期：</p><p><img src="Life-cycle.png" alt="life-cyc"></p><p>这是一个比较全的生命周期，我们为了方便理解可以拆解成TCC的周期图（实际上，AT可以理解为自动的TCC逻辑），首先是try阶段：<br><img src="at-try.png" alt="at-try"><br>对于RDBMS来说，在第一阶段我们的事务其实已经提交了，而在全局事务的上下文中，这部分数据是为提交的，这就导致了对于全局事务来说隔离级别是读未提交的，Seata默认的全局隔离级别是读已提交，而其可以指定读为提交，这里就是通过Seata代理parse SQL然后帮你改成SELECT FOR UPDATE实现的了。</p><p>而当所有分支事务完成，RM的主流程结束，此时并不需要更多的同步协同处理，只需要清理之前的undo log即可:<br><img src="at-confime.png" alt="at-commit"></p><p>而如果决议是回滚，各分支事务就可以通过回滚日志进行各业务的回滚:<br><img src="at-rollback.png" alt="at-cancel"></p><p>总结一下，通过DTP已经基本实现了事务的原子性，而数据层面上对于分布式数据来说存在中间状态(默认情况下)，所以存在数据一致的问题，对于部分已提交的分支事务是可读的，在一致性上做出了让步，而为了保证事务的隔离，这部分中间态的数据是「只读」的，这里的只读是seata事务上下文的只读，前面说到AT会代理数据连接，自然就可以做到SQL的parse，而对于任意AT事务分支，都会根据修改的数据主键上一个GlobalLock，在分支事务commit时会尝试获取资源。</p><p>这个GlobalLock我们可以简单的理解成分布式锁，这个锁是由TC维护的，执行一个Try阶段的事务分支（Client）会执行以下的操作：</p><ul><li>执行本地业务SQL</li><li>尝试获取全局锁</li><li>获取到全局锁则提交本地事务，失败则重试，重试超出限制则回滚  </li></ul><p>这里有一个需要特殊说明的是@GlobalLock是默认加在@GlobalTransaction和其下链路上的，而手动指定@GlobalLock可以将可能依赖到事务进行过程中软状态数据的数据隔离，而对于不需要进行上锁或纳入事务管理的（日志/冗余记录）的可以手动@IgnoreGlobalLock将这部分行为推出seata事务周期。</p><p>以上就是从ACID角度来看的AT模式的设计和方案，对于业务接入与实现来说，因为主要实现在于DataSource Proxy &amp; Transaction Coordinator，补偿都是自动生成的undo log，接入客户端只需要实现rpc的切面来注册发起与事务感知即可，所以接入侵入性小，单一注解即可达到一个分布式事务的支持。</p><h2 id="TCC实现"><a href="#TCC实现" class="headerlink" title="TCC实现"></a>TCC实现</h2><p>上面我们说到AT是基于JDBC代理拦截SQL解析生成补偿SQL(undo log table)并交由全局锁维护数据写隔离来实现分布式事务的，而对于一些在DBMS以外的系统其实是无法支持相应的自动补偿的，此时我们该如何去实现支持减轻手动补偿的压力呢？</p><ol><li>通过注册cancel阶段的业务回调去做补偿（我没有确认是否seata有做这方面的支持，不过一般来说都会提供相应的扩展点）。</li><li>选择使用更加可拓展的TCC实现。</li></ol><p>对于第二点，本身AT就是TCC的一种实现，只需要开放对应的接口即可，这里只需要对AT模式做基本的功能裁剪即可做到支持（当然Seata也是这么干的）：<br><img src="tcc.png" alt="tcc"></p><p>需要注意的是，裁剪后的TCC是不在GlobalLock上下文中的，你可以手动指定，也可以自己实现隔离（自己的分布式锁？）。</p><h2 id="SAGA"><a href="#SAGA" class="headerlink" title="SAGA"></a>SAGA</h2><p><img src="saga.png" alt="saga"></p><p>对于长链路的复杂调用我们自动补偿或者要求强数据一致会带来很大的性能负担，很多时候我们只需要最终一致性的时候我们更应该选择SAGA来进行我们的事务处理。</p><p>SAGA维护了调用链路服务的状态机，在一个状态失败后，会选择尝试补偿或者回滚，这个和TCC很像，需要编码自己实现，不过整体方案对整个事务的性能消耗大大优于TCC，而业界的SAGA实现主要是两种，一种基本状态机或流程引擎通过 DSL 方式编排流程程和补偿定义，一种是基于 Java 注解+拦截器实现补偿，我们简单对比一下两种方案：</p><p><img src="saga-table.png" alt="saga"></p><p>Seata是状态机和 DSL 方式编排流程实现，</p><ul><li><p>通过状态图来定义服务调用的流程并生成 json 状态语言定义文件；</p></li><li><p>状态图中一个节点可以是调用一个服务，节点可以配置它的补偿节点；</p></li><li><p>状态图 json 由状态机引擎驱动执行，当出现异常时状态引擎反向执行已成功节点对应的补偿节点将事务回滚；注意: 异常发生时是否进行补偿也可由用户自定义决定</p></li><li><p>可以实现服务编排需求，支持单项选择、并发、异步、子状态机、参数转换、参数映射、服务执行状态判断、异常捕获等功能；</p></li></ul><h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><p>我们讲MQ实现事务时到底是怎么实现：</p><p><img src="%E5%9F%BA%E4%BA%8E%E6%B6%88%E6%81%AF%E7%9A%84%E4%BA%8B%E5%8A%A1.png" alt="mq"></p><p>生产者</p><ul><li>执行业务</li><li>插入消息状态表并提交</li><li>异步发送消息</li><li>更新消息状态  </li></ul><p>发送兜底定时job：</p><ul><li>获取未发送状态消息记录</li><li>重发并更新消息状态  </li></ul><p>消费者</p><ul><li>接收消息</li><li>消息入库</li><li>异步执行业务（必须幂等）并更新消息状态  </li></ul><p>消费兜底定时job：</p><ul><li>获取非终态的消息记录</li><li>根据消息进行重试并更新状态 </li></ul><p>这以上是比较原始的mq来做分布式事务的例子，正常情况下我们有很多mq特性进行上述步骤的简化。</p><h3 id="消息手动确认"><a href="#消息手动确认" class="headerlink" title="消息手动确认"></a>消息手动确认</h3><p>通过消息手动确认来简化生产者消息状态机和补偿job，此时消费者消费逻辑：</p><ul><li>接收消息</li><li>处理并执行业务</li><li>手动确认<br>当消费业务过程发生异常状态，则无法真正消费消息并将交由mq来进行重试。</li></ul><h3 id="半消息确认发送"><a href="#半消息确认发送" class="headerlink" title="半消息确认发送"></a>半消息确认发送</h3><p>通过半消息简化发送方的状态机和补偿job，此时生产者生产逻辑：</p><ul><li>发送Half message</li><li>处理业务</li><li>commit message</li></ul><p>当生产业务过程发生异常状态，则消息一直是挂起状态，当超过配置定时，将由mq发起事务状态回查，而生产方需要对接回查接口，根据当前状态机告诉mq是否commit或者取消发送。<br>这里存在几种常见异常：</p><ol><li>发消息失败</li><li>业务失败</li><li>commit fail</li></ol><p>发送失败没有意义，而当业务失败，mq回查时，我们根据状态机告知取消发送，mq将清理半消息；而当因为网络问题commit fail时，回查后会重发，确保发送方的发送是事务性的，所以也叫事务性消息。</p><p>简化后的事务消息：</p><p><img src="%E7%AE%80%E5%8C%96%E5%90%8E%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png" alt="简化后的事务消息"></p><h2 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h2><p>我们无法通过拿到圣杯实现一切愿望，我们找不到银弹解决一切问题。</p><p>在对于分布式事务以及一致性的上下文中始终要有一些取舍，业务侵入性、性能损耗、数据一致性无法同时保证，我们要根据实际情况进行具体的评估实现。</p><table><thead><tr><th align="left"></th><th align="center">业务侵入</th><th align="center">性能损耗</th><th align="center">隔离性</th><th align="center">补偿方式</th><th align="center">复杂链路动态路由</th><th>资源</th></tr></thead><tbody><tr><td align="left">MQ</td><td align="center">中</td><td align="center">低</td><td align="center">读未提交</td><td align="center">-</td><td align="center">-</td><td>All</td></tr><tr><td align="left">AT</td><td align="center">低</td><td align="center">高</td><td align="center">读未提交(可支持至已提交)</td><td align="center">自动补偿</td><td align="center">-</td><td>支持ACID的DBMS</td></tr><tr><td align="left">TCC</td><td align="center">高</td><td align="center">中</td><td align="center">读未提交</td><td align="center">手动实现</td><td align="center">-</td><td>All</td></tr><tr><td align="left">SAGA</td><td align="center">高</td><td align="center">中</td><td align="center">读未提交</td><td align="center">手动实现</td><td align="center">-</td><td>All</td></tr><tr><td align="left">XA</td><td align="center">低</td><td align="center">高</td><td align="center">读已提交</td><td align="center">自动补偿</td><td align="center">可配置化DSL+状态机</td><td>支持XA协议的DBMS</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf" target="_blank" rel="noopener">Distributed Transaction Processing: The XA Specification</a></li><li><a href="https://github.com/seata/seata/wiki/AT-Mode" target="_blank" rel="noopener">at-mode wiki</a></li><li><a href="https://github.com/seata/seata/wiki/MT-Mode" target="_blank" rel="noopener">mt-mode wiki</a></li><li>《设计数据密集型应用程序》    —– Martin Kleppmann</li><li><a href="https://segmentfault.com/a/1190000018956054" target="_blank" rel="noopener">源码｜详解分布式事务之 Seata-Client 原理及流程</a></li><li><a href="https://myslide.cn/slides/18426" target="_blank" rel="noopener">Seata 在微服务一致性中的探索 季敏</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/UDP总结与梳理</title>
      <link href="2020/12/06/TCP-UDP%E6%80%BB%E7%BB%93%E4%B8%8E%E6%A2%B3%E7%90%86/"/>
      <url>2020/12/06/TCP-UDP%E6%80%BB%E7%BB%93%E4%B8%8E%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>TCP也是老生常谈了，在四层协议栈中基本是必知必会，还拥有大量的八股文面试内容，本篇旨在思考与总结协议栈的相关知识，梳理一下加深一下理解，也希望能有更深入的理解，不是面向面试学习。</p> <a id="more"></a><h2 id="讲讲TCP"><a href="#讲讲TCP" class="headerlink" title="讲讲TCP"></a>讲讲TCP</h2><p>应用层协议总是离不开TCP作为基础，面向连接为应用层协议屏蔽了更多的网络层的感知，那什么是「面向连接」？</p><p><a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC 793 - Transmission Control Protocol</a></p><p>第四页：</p><blockquote><p>Connections:</p><p>   ​     The reliability and flow control mechanisms described above require<br>   ​     that TCPs initialize and maintain certain status information for<br>   ​     each data stream.  The combination of this information, including<br>   ​     sockets, sequence numbers, and window sizes, is called a connection.</p></blockquote><p>告诉我们连接用于保证可靠性和流控制机制的信息，包括了三个部分：</p><pre><code>* Socket* 序列号* 窗口大小</code></pre><p>那么我们可以理解为对与一个连接来说，需要维护两端的上述三种信息共识：连接Socket用于标示基础信息：互联网地址标示、端口信息；窗口用来做流量控制；序列号用来追踪发送顺序与发送状态的确认。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>那如何建立这三种信息的基本共识呢？又回到了大家熟悉无比的三次握手：</p><p><img src="basic-3-way-handshake.png" alt="basic-3-way-handshake"></p><p>需要注意的是，这里说三次握手建立三种信息共识并不是说三次握手的主要目的是建立三种信息的共识，共识严格来说基于约定，要完全保证100%安全可靠的共识和这里说的共识不是一路货色，这里只是说这个基本共识在这三次握手的过程中达成了。</p><p>那么就有了一些延伸的问题，为什么要三次握手才能实现共识？四次行不行？两次行不行？为了什么？</p><p>相信大家但凡面试都躲不过这几个烂问题，求职者也是基于各路博客自身理解各显神通然后将这问题扣上一顶「八股文」的大帽打入冷宫不在思考，但是这样真的好么？</p><h4 id="关于次数的思考"><a href="#关于次数的思考" class="headerlink" title="关于次数的思考"></a>关于次数的思考</h4><p>首先我们不考虑使用四次行不行这种问题，如果一个事情能用三次解决就必然可以用四次解决，同样也可以100次解决，只是效率低而已，我们不需要进行拓展的讨论。</p><p>那么少点呢？用两次可以么？A告诉B自己的地址/序列号/窗口大小，B再告诉A自己的地址/序列号/窗口大小是不是就可以了呢？</p><p>实际上，在完美的网络环境下（所有均可达/均有序）确实可以，但是网络总是充满了不确定性：</p><p><img src="tcp-recovery-from-old-duplicate-syn.png" alt="tcp-recovery-from-old-duplicate-syn"></p><p>只要网络状况不好，A发起重试，两个请求连接的数据包到B，B该如何处置？丢弃哪一个，如何分辨是不是因为网络超时而晚到的历史连接？</p><p>所以便有了三次握手与RST控制消息，将连接的建立权移交给连接发起放，接受方将连接建立的序列号+1作为当前连接建立的回复序列号发送给发起方（SEQ）,发起方就可以根据SEQ反推出发起的连接是否超时，超时则回复RST释放资源，正常则ACK确认连接。你看，这下连序列号同步（SYN）也做了，自然就不需要第四次握手了。</p><p>RFC中也是说明主要解决重复的历史连接问题：<br><a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC 793 - Transmission Control Protocol</a></p><p>第31页：</p><blockquote><p>The principle reason for the three-way handshake is to prevent old<br>duplicate connection initiations from causing confusion.</p></blockquote><p>RFC中也有示意图，童鞋们自行采阅。</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>连接建立啦，自然要开始传输信息了，那么我们该如何传输数据呢？直接怼上去一个包搞定所有数据那肯定不行🙅，万一我这数据多咋整，链路上设备不支持给我包阉了咋整？所以我们在发送前，还要做好分包，做分包前还要知道当前链路支持我怎么分包，那么问题简化为一下三个步骤：</p><ul><li>调查链路上可以接受的包大小</li><li>分析当前数据大小进行拆包</li><li>发送数据包并填充序列号</li><li>接收端获取数据包并回复ACK</li><li>发送方获取ACK移动发送窗口or重发</li></ul><h4 id="如何调查链路上可以接受的包大小？"><a href="#如何调查链路上可以接受的包大小？" class="headerlink" title="如何调查链路上可以接受的包大小？"></a>如何调查链路上可以接受的包大小？</h4><p>这里有个「路径最大传输单元发现」（Path MTU Discovery，PMTUD）机制来确定两个主机间的最大传输单元（MTU）,工作原理如下：</p><ol><li>向目的主机发送 IP 头中 DF 控制位为 1 的数据包，DF 是不分片（Don’t Fragment，DF）的缩写</li><li>路径上的网络设备根据数据包的大小和自己的 MTU 做出不同的决定：<ul><li>如果数据包大于设备的 MTU，就会丢弃数据包并发回一个包含该设备 MTU 的 ICMP 消息；</li><li>如果数据包小于设备的 MTU，就会继续向目的主机传递数据包；</li></ul></li><li>源主机收到 ICMP 消息后，会不断使用新的 MTU 发送 IP 数据包，直到 IP 数据包达到目的主机</li></ol><p>这里有个问题需要注意，linux默认是开启该方式的，你可以通过修改配置关闭PMTUD配置，那么会在发真实数据的时候被中间链路的设备拒绝，然后再重新设置MTU进行重试。</p><p>一般的路由设备的MTU是1500个字节，</p><ul><li>对于IP协议来说，要剪掉20个协议头的大小，那么通常的IP包就是1480个字节</li><li>对于TCP协议来说，要剪掉20个IP协议头，20个TCP协议头，就是1460个字节</li><li>对于UDP协议来说，要剪掉20个IP协议头，8个UDP协议头，就是1472个字节</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>因为TCP是全双工，所以需要确定双方不在发送数据。</p><ul><li>第1次挥手由客户端向服务端发起，服务端收到信息后就能确定客户端已经停止发送数据。</li><li>第2次挥手由服务端向客户端发起，客户端收到消息后就能确定服务端已经知道客户端不会再发送数据。</li><li>第3次挥手由服务端向客户端发起，客户端收到消息后就能确定服务端已经停止发送数据。</li><li>第4次挥手由客户端向服务端发起，服务端收到信息后就能确定客户端已经知道服务端不会再发送数据。</li></ul><p><a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC 793 - Transmission Control Protocol</a><br>第38页</p><blockquote><pre><code>TCP A                                                TCP B</code></pre><p> 1  ESTABLISHED                                          ESTABLISHED</p><p> 2  (Close)<br>     FIN-WAIT-1  –&gt; &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;  –&gt; CLOSE-WAIT</p><p> 3  FIN-WAIT-2  &lt;– &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;      &lt;– CLOSE-WAIT</p><p> 4                                                       (Close)<br>     TIME-WAIT   &lt;– &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=FIN,ACK&gt;  &lt;– LAST-ACK</p><p> 5  TIME-WAIT   –&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      –&gt; CLOSED</p><p> 6  (2 MSL)<br>     CLOSED</p></blockquote><h4 id="为什么第二次第三次不能合并呢？"><a href="#为什么第二次第三次不能合并呢？" class="headerlink" title="为什么第二次第三次不能合并呢？"></a>为什么第二次第三次不能合并呢？</h4><p> 因为挥手由客户端发起，客户端通知服务端不发数据了，但是服务端可能还在发送数据会客户端，所以只能先确认收到，再等自己发送内容结束后再发送不在发送的通知。</p><h4 id="为什么客户端有TIME-WAIT"><a href="#为什么客户端有TIME-WAIT" class="headerlink" title="为什么客户端有TIME WAIT"></a>为什么客户端有TIME WAIT</h4><ul><li>第一，为了保证客户端发送的最后一个ACK 报文能够到达服务器。我们必须假设网络是不可靠的，ACK 报文可能丢失。如果服务端发出FIN 报文后没有收到ACK 报文，就会重发FIN 报文，此时处于TIME-WAIT状态的客户端就会重发ACK 报文。当然，客户端也不能无限久的等待这个可能存在的FIN 报文，因为如果服务端正常接收到了ACK 报文后是不会再发FIN 报文的。因此，客户端需要设置一个计时器，那么等待多久最合适呢？所谓的MSL（Maximum Segment Lifetime）指一个报文在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL时间后，客户端都没有再次收到FIN 报文，那么客户端推断ACK 报文已经被服务器成功接收，所以结束TCP 连接。</li><li>第二，防止已失效的连接请求报文段出现在新的连接中。客户端在发送完最后一个ACK 报文后，再经过时间2MSL，就可以使由于网络不通畅产生的滞留报文段失效。这样下一个新的连接中就不会出现旧的连接请求报文。</li></ul><h4 id="同时发起的关闭请求"><a href="#同时发起的关闭请求" class="headerlink" title="同时发起的关闭请求"></a>同时发起的关闭请求</h4><p>  特殊的，客户端与服务端都传输完毕发起关闭请求也是存在的<br>  <a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC 793 - Transmission Control Protocol</a><br>第38页</p><blockquote><pre><code>TCP A                                                TCP B</code></pre><p> 1  ESTABLISHED                                          ESTABLISHED</p><p> 2  (Close)                                              (Close)<br>     FIN-WAIT-1  –&gt; &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;  … FIN-WAIT-1<br>                 &lt;– &lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;CTL=FIN,ACK&gt;  &lt;–<br>                 … &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;  –&gt;</p><p> 3  CLOSING     –&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      … CLOSING<br>                 &lt;– &lt;SEQ=301&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;      &lt;–<br>                 … &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      –&gt;</p><p> 4  TIME-WAIT                                            TIME-WAIT<br>     (2 MSL)                                              (2 MSL)<br>     CLOSED                                               CLOSED</p></blockquote><h3 id="TCP的性能问题"><a href="#TCP的性能问题" class="headerlink" title="TCP的性能问题"></a>TCP的性能问题</h3><p>我们可以看到，RFC793都快四十年了，基础网络环境已经发生的翻天覆地的变化，所以自然的，TCP协议自然也带来的新能的问题，在网络发展的早期，包从发送到到达慢的主要原因来自与网络带宽的限制，是由于拥塞导致的，而TCP自然的就认为在包传输失败重传时将会采用拥塞阻塞的避免算法，详细的可以看<a href="https://noir-lattice.github.io/2020/05/16/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">TCP拥塞控制与滑动窗口</a>，这种就是明显的历史原因了。</p><p>再者，TCP的三次握手与四次挥手也带来了不小的服务端与客户端的性能消耗，在维护状态机的同实Socket占用与资源释放缓慢。</p><p>还有就是重试机制在极限网络环境下带来的负担，高时延导致的大量超时ACK在重试后获取，而重试的报文又占用了带宽使网络环境更差。</p><p>总结一下，TCP存在性能问题主要体现在以下几个点：</p><ul><li>拥塞避免会自动降低吞吐</li><li>握手与挥手带来的性能损耗</li><li>重试导致的带宽负担</li></ul><h2 id="讲讲UDP"><a href="#讲讲UDP" class="headerlink" title="讲讲UDP"></a>讲讲UDP</h2><p>UDP 协议一般作为流媒体应用、语音交流、视频会议所使用的传输层协议，我们大家都知道的 DNS 协议底层也使用了 UDP 协议(这个说法不严谨，TCP也是有用的)，这些应用或协议之所以选择 UDP 主要是因为以下这几点：</p><ul><li>速度快:<br>这里主要相对于TCP的拥塞控制而言，对于现今的网络环境，丢包是很常见的，不存在拥塞控制会加速基础的网络报文交互。</li><li>无连接：<br>不需要三次握手，不需要三次挥手，无连接可以减少很多前置的性能损耗</li><li>无状态<br>没有连接状态，不用维护状态机，且不需要确认与重传</li><li>头部小<br>这个在上面有说过，因为不需要很多的状态机维护，所以可以省略很多标志位与头部信息，只需要基础的目标与来源信息，使UDP头仅仅需要占用8个字节</li></ul><h3 id="8个字节的请求头"><a href="#8个字节的请求头" class="headerlink" title="8个字节的请求头"></a>8个字节的请求头</h3><p>有4个信息，每个都是2个字节，分别是：</p><ul><li>源端口</li><li>目的端口</li><li>长度</li><li>校验码<br>特殊的，源端口是可选字段，校验码也可以置为0，而长度虽然占了两个字节，但是一般受限于MTU，指定不指定意义不大，所以真正有意义且必选的就只有目的端口了（那为啥不简化更轻？）</li></ul><h3 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h3><p>为什么流媒体应用更加倾向于UDP？一则是流媒体的时效性要求使得重传重放与连接状态并不重要，一则是更小的头部可以提供更大的包体加速整体吞吐。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>在早期域名少，内容压力不大的时候DNS基本由DNS支持，但因为后续互联网的发展，UDP受MTU的限制，TCP成为的UDP的兜底方案，即使用UDP发送失败（MTU限制）后启用TCP进行信息传输。</p><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>google quic也是UDP实现，这个单独启一篇，且听下回分解。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象设计原则</title>
      <link href="2020/10/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>2020/10/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="OOP设计原则"><a href="#OOP设计原则" class="headerlink" title="OOP设计原则"></a>OOP设计原则</h2><p>虽然工作没几年，忘得却挺快，昨天面荔枝别的都还能说个一二，这玩意就不知道为啥小脑瓜子一片空白。。。。。。</p><p>也不能说面向面试吧，主要感觉不写一遍过一阵又还给老师了。  </p><p>以下展开列举设计原则，*代表类的设计原则，其他为包的设计原则。</p><h3 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP） *"></a>单一职责原则（SRP） *</h3><p><strong>There should never be more than one reason for a class to change.</strong><br>应该有且仅有一个原因引起类的变更，原则限制了类、接口甚至于方法的粒度不宜过粗。</p><p>妥协： 当逻辑简单且方法数量少时，可以暂时违背SRP，但实际过程中发生了职责扩散导致复杂度慢慢提升时，应及时拆分遵循SRP。</p><h3 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP） *"></a>开闭原则（OCP） *</h3><p><strong>Software entities like classes, modules and functions should be open for extension but closed for modifications.</strong><br>软件实体如类、模块和方法应该开放拓展但是关闭更改。</p><h3 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP） *"></a>里氏替换原则（LSP） *</h3><p><strong>Functions that use pointers or referrnces to base classes must be able to use objects of derived classes without knowing it.</strong><br>所有引用基类的地方必须能透明地使用其子类的对象。</p><h3 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP） *"></a>依赖倒置原则（DIP） *</h3><p><strong>High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.</strong><br>高级模块不应该依赖低级底层模块，二者都应该依赖其抽象，抽象不应该依赖其细节（实现），细节应该依赖于抽象。</p><h3 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP） *"></a>接口隔离原则（ISP） *</h3><p><strong>Clients should not be forced to depend upon interfaces that they don’t use.</strong><br>客户端不应该依赖它不需要的接口</p><h3 id="迪米特法则-最少知识法则（LoD-LKP）"><a href="#迪米特法则-最少知识法则（LoD-LKP）" class="headerlink" title="迪米特法则/最少知识法则（LoD/LKP）"></a>迪米特法则/最少知识法则（LoD/LKP）</h3><p><strong>Only talk to your immedate friends.</strong><br>只与直接朋友对话。</p><h3 id="重用发布等价原则（REP）"><a href="#重用发布等价原则（REP）" class="headerlink" title="重用发布等价原则（REP）"></a>重用发布等价原则（REP）</h3><p>重用的粒度就是发布的粒度。</p><h3 id="共同封闭原则（CCP）"><a href="#共同封闭原则（CCP）" class="headerlink" title="共同封闭原则（CCP）"></a>共同封闭原则（CCP）</h3><p>包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，而对于其它的包不造成任何影响。</p><h3 id="共同重用原则（CRP）"><a href="#共同重用原则（CRP）" class="headerlink" title="共同重用原则（CRP）"></a>共同重用原则（CRP）</h3><p>一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中的所有类。</p><h3 id="无环依赖原则（ADP）"><a href="#无环依赖原则（ADP）" class="headerlink" title="无环依赖原则（ADP）"></a>无环依赖原则（ADP）</h3><p>在包的依赖关系图中不允许存在环。</p><h3 id="稳定依赖原则（ADP）"><a href="#稳定依赖原则（ADP）" class="headerlink" title="稳定依赖原则（ADP）"></a>稳定依赖原则（ADP）</h3><p>朝着稳定的方向进行依赖。</p><h3 id="稳定抽象原则（SAP）"><a href="#稳定抽象原则（SAP）" class="headerlink" title="稳定抽象原则（SAP）"></a>稳定抽象原则（SAP）</h3><p>包的抽象程度应该和其稳定程度一致。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计原则 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU的几种写法</title>
      <link href="2020/10/08/LRU%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/"/>
      <url>2020/10/08/LRU%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LRU （Least Recently Used，最近最少使用）算法是操作系统中一种经典的页面置换算法，这么卷的环境下肯定要会手写拉，这篇就是讲茴字的几种写法。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>简单来说就一个链表，左端入，清理最右，插入与查询都是O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkListLRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双端链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Node&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cache大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取命中index</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> -1 为找不到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;Node&gt; iterator = cache.descendingIterator();</span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Node node = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (node.key == key) &#123;</span><br><span class="line">                result = node.val;</span><br><span class="line">                iterator.remove(); <span class="comment">// remove node</span></span><br><span class="line">                put(key, result); <span class="comment">// reput node</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试命中已存在并删除对应node</span></span><br><span class="line">        Iterator&lt;Node&gt; iterator = cache.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Node node = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (node.key == key) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (capacity == cache.size()) &#123;</span><br><span class="line">            <span class="comment">// 缓存满，删除链表头</span></span><br><span class="line">            cache.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        cache.add(<span class="keyword">new</span> Node(key, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希链表"><a href="#哈希链表" class="headerlink" title="哈希链表"></a>哈希链表</h2><p>用LinkedHashMap代替LinkedList，插入与查询都是O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashLinkListLRUCache</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 哈希链表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> LinkedHashMap&lt;Integer, Integer&gt; cache;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 缓存容量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashLinkListLRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取命中index</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> -1 为找不到</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val = cache.get(key);</span><br><span class="line">    cache.remove(key);</span><br><span class="line">    cache.put(key, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">      cache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (capacity == cache.size()) &#123;</span><br><span class="line">      Set&lt;Integer&gt; keySet = cache.keySet();</span><br><span class="line">      Iterator&lt;Integer&gt; iterator = keySet.iterator();</span><br><span class="line">      cache.remove(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">当然，也可以重写LinkedHashMap#removeEldestEntry(Map.Entry)</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashLinkListLRUCache</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 哈希链表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashLinkListLRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(java.util.Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取命中index</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> -1 为找不到</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val = cache.get(key);</span><br><span class="line">    cache.remove(key);</span><br><span class="line">    cache.put(key, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">      cache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通用一点"><a href="#通用一点" class="headerlink" title="通用一点"></a>通用一点</h2><p>改的给阳间一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * cache容器大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化cache大小</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> capacity cache大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(capacity);</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓄水池抽样</title>
      <link href="2020/10/08/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/"/>
      <url>2020/10/08/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="场景简述"><a href="#场景简述" class="headerlink" title="场景简述"></a>场景简述</h2><p>当我们需要对一个非常大的数据集合进行抽样时，我们不可能降数据完全捞取到内存里，这就导致我们需要使用流处理来进行抽样。而一个很长的N的流，在处理完成前都不知道N的大小，那如何在时间复杂度O(N)的情况下进行抽样呢？</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>我们假设先有nums[N], N=3，需要取其中1个值：</p><ul><li>假定第一位数被抽中的概率为 1 / 0 + 1, 有 <code>pick = random() % 1 ? nums[0] : pick;</code>，可知此时pick命中nums[0]</li><li>第二位数被抽取中的概率为 1 / 1 + 1，有<code>pick = random() % 2 ? nums[1] : pick</code>，此时pick有1/2概率命中nums[1]</li><li>第三位数被抽中的概率为 1 / 2 + 1，有<code>pick = random() % 3 ? nums[2] : pick</code>，此时pick有1/3的概率命中nums[2]  </li></ul><p>通过上述三个步骤后，我们计算下命中第n个数的概率Pn: </p><ul><li>P1：1 * 1/2 * 2/3 = 1/3</li><li>P2: 1/2 * 2/3 = 1/3</li><li>P3: 1/3  </li></ul><p>其实很简单可以分析出使用此类方式命中Pn有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  Pn = 1 / n * n / (n + 1) * (n + 1) / (n + 2) ...... * (N - 1) / N</span><br><span class="line"></span><br><span class="line">=&gt; Pn = 1 / N</span><br></pre></td></tr></table></figure><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>老规矩，做题：</p><ul><li><a href="https://leetcode-cn.com/problems/random-pick-index/" target="_blank" rel="noopener">398. 随机数索引</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-random-node/" target="_blank" rel="noopener">382. 链表随机节点</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抽样 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊Dijkstra</title>
      <link href="2020/10/02/%E8%81%8A%E8%81%8ADijkstra/"/>
      <url>2020/10/02/%E8%81%8A%E8%81%8ADijkstra/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通常的，Dijkstra用于寻路，解决的是有权图中最短路径的问题，我们将<del>做个题</del>从一个例子来解释这件事。<br><img src="%E9%B2%A8%E9%B1%BC.jpg" alt="鲨鱼"></p><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>做题家们的首要准则，就是看题，看准题，如图：<br><img src="1.png" alt="1"><br>求A到F的最短路径。</p><p>简单的分析一下：</p><ul><li>有向有权</li><li>每一跳的最短路径都是上一跳加权最优选择</li></ul><h3 id="需要的额外空间"><a href="#需要的额外空间" class="headerlink" title="需要的额外空间"></a>需要的额外空间</h3><ol><li><p>临接矩阵</p></li><li><p>记录扫描集合s={}</p></li><li><p>记录从起始点到对应位置距离的集合dis,默认为dis={∞,∞,∞,∞,∞,∞}</p><p>下面我们就这样表示：<br><img src="table1.png" alt="初始状态"></p></li></ol><h3 id="开始寻路"><a href="#开始寻路" class="headerlink" title="开始寻路"></a>开始寻路</h3><ul><li>从入口A开始<br><img src="s_1.png" alt="s1"><br>我们可以分析出距离当前集合最近的是B</li><li>A -&gt; B<br><img src="s_2.png" alt="s2"><br>此时，可知距离当前集合最近的节点是D</li><li>A -&gt; B -&gt; D<br><img src="s_3.png" alt="s3"><br>此时，可知距离当前集合最近的节点是C</li><li>A -&gt; B -&gt; D -&gt; C<br><img src="s_4.png" alt="s4"><br>此时距离当前集合最近的是节点e</li><li>A -&gt; B -&gt; D -&gt; C -&gt; E<br><img src="s_5.png" alt="s5"><br>此时发现距离当前集合最近的是终点，结束寻路，获取最短距离。</li></ul><h3 id="分析一下"><a href="#分析一下" class="headerlink" title="分析一下"></a>分析一下</h3><p>  整体Dijkstra感觉像是广度优先的变种，为了寻找最优不断的把扫描集合附件的点加入进来，整体的时间复杂度O(n^2)，可以预见的是n非常大而结果目标很远时整体的效率堪忧。</p><p>  Leetcode相关题目：  </p><ul><li><a href="https://leetcode-cn.com/problems/network-delay-time/" target="_blank" rel="noopener">743.网络延迟时间</a>  </li><li><a href="https://leetcode-cn.com/problems/swim-in-rising-water/" target="_blank" rel="noopener">778.水位上升的泳池中游泳</a></li><li><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener">407.接雨水 II</a></li></ul><p>刷完咱们去玩A*，爷青回！！！( •̀ ω •́ )y</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 寻路算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Gateway接入Sentinel</title>
      <link href="2020/10/01/Spring-Cloud-Gateway%E6%8E%A5%E5%85%A5Sentinel/"/>
      <url>2020/10/01/Spring-Cloud-Gateway%E6%8E%A5%E5%85%A5Sentinel/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文用作记录Sentinel接入Spring Cloud Alibaba。</p><h2 id="搭建Sentinel-Dashboard"><a href="#搭建Sentinel-Dashboard" class="headerlink" title="搭建Sentinel Dashboard"></a>搭建Sentinel Dashboard</h2><ul><li><p><a href="https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0" target="_blank" rel="noopener">官方jar包启动</a></p></li><li><p>docker启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=always -d -it --name sentinel-dashboard -p 8858:8858 bladex/sentinel-dashboard</span><br></pre></td></tr></table></figure></li></ul><p>当然我直接在Rancher商城里面直接构建的（嘿嘿</p><h2 id="项目引入"><a href="#项目引入" class="headerlink" title="项目引入"></a>项目引入</h2><ul><li><p>添加mvn依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-sentinel-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加配置</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span>  <span class="comment"># sentinel规则接接收客户端口</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.50</span><span class="string">:8858</span></span><br></pre></td></tr></table></figure><ul><li>随便发起一个请求后可以在sentinel dashboard看到对应服务</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud Alibaba </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud Gateway接入nacos动态路由刷新</title>
      <link href="2020/10/01/Spring-Cloud-Gateway%E6%8E%A5%E5%85%A5nacos%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%88%B7%E6%96%B0/"/>
      <url>2020/10/01/Spring-Cloud-Gateway%E6%8E%A5%E5%85%A5nacos%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%88%B7%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通常在Nacos接入了Spring Cloud的Gateway后还需自定义实现动态的路由配置来提供后续更为灵活的接口发布与维护，这里主要记录实现步骤。</p><h2 id="接入Nacos做naming"><a href="#接入Nacos做naming" class="headerlink" title="接入Nacos做naming"></a>接入Nacos做naming</h2><ul><li><p>添加mvn依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加配置</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">    <span class="attr">main:</span></span><br><span class="line">      <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">      <span class="attr">nacos:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">          <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">          <span class="comment">#    bootstrap:</span></span><br><span class="line">          <span class="comment">#      enable: true</span></span><br><span class="line">          <span class="attr">data-id:</span> <span class="string">hellorobot-gateway</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">yaml</span></span><br><span class="line">          <span class="attr">auto-refresh:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">discovery:</span></span><br><span class="line">          <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">          <span class="attr">register:</span></span><br><span class="line">          <span class="attr">service-name:</span> <span class="string">gateway</span></span><br><span class="line">          <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">        <span class="attr">gateway:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">routes:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">                <span class="attr">uri:</span> <span class="string">http://localhost:8002</span></span><br><span class="line">                <span class="attr">predicates:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">Path=/api/user/**</span></span><br><span class="line">                <span class="attr">filters:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">RewritePath=/api/user,</span> <span class="string">/user/admin</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="动态更新配置文件"><a href="#动态更新配置文件" class="headerlink" title="动态更新配置文件"></a>动态更新配置文件</h2><p>指定路由配置文件，用于启动时创建Nacos Config文件监听  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"dynamic-config"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicRoutingFileProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置文件id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String dataId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String groupId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long timeout = <span class="number">3000L</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ul><li>DynamicRouteServiceImpl  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 动态路由服务实现</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 具体的路由信息变更刷新，因监听文件更新仅可拿到全量的路由配置，</span></span><br><span class="line"><span class="comment">    * 为了减轻整体逻辑负担，使用merge逻辑更新definition并发出变</span></span><br><span class="line"><span class="comment">    * 更通知。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 虽然仅变更不通知，可以简易的通过全量删除并全量添加即可实现路由</span></span><br><span class="line"><span class="comment">    * 更新，但并不保证后续是否存在对历史definition对象的引用，故此</span></span><br><span class="line"><span class="comment">    * 处使用更保险的策略。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 又因为merge策略，可能导致对部分definition更新后会影响默认的</span></span><br><span class="line"><span class="comment">    * order,所以在添加注册时会填充未标记的order。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Slf</span>4j</span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicRouteServiceImpl</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> RouteDefinitionRepository routeDefinitionRepository;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * merge更新路由</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 保证刷新逻辑不存在线程安全问题，刷新路由并没有很高的性能需求，此处锁住整个refresh方法。</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> definitions 路由详情集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(List&lt;RouteDefinition&gt; definitions)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 填充生成order</span></span><br><span class="line">            fillTargetRouteOrder(definitions);</span><br><span class="line">            <span class="comment">// 目标routes id集合</span></span><br><span class="line">            List&lt;String&gt; targetDefIds = definitions.stream().map(RouteDefinition::getId).collect(Collectors.toList());</span><br><span class="line">            <span class="comment">// 获取现存所有路由map</span></span><br><span class="line">            Map&lt;String, RouteDefinition&gt; aliveRouteMap = getAliveRouteMap();</span><br><span class="line">            <span class="comment">// 删除失效的routes</span></span><br><span class="line">            removeDefinitions(targetDefIds, aliveRouteMap);</span><br><span class="line">            <span class="comment">// 更新definitions</span></span><br><span class="line">            updateDefinitions(definitions, aliveRouteMap);</span><br><span class="line">            <span class="comment">// 添加definitions</span></span><br><span class="line">            createDefinitions(definitions, aliveRouteMap);</span><br><span class="line">            <span class="comment">// 发布路由已更新时间</span></span><br><span class="line">            publishRouteChangedEvent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 填充目标路由order</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> definitions 路由详情集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fillTargetRouteOrder</span><span class="params">(List&lt;RouteDefinition&gt; definitions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> order = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (RouteDefinition route : definitions) &#123;</span><br><span class="line">                <span class="keyword">if</span> (route.getOrder() == <span class="number">0</span>) &#123;</span><br><span class="line">                    route.setOrder(order++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 发布路由已更新消息</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishRouteChangedEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.publisher.publishEvent(<span class="keyword">new</span> RefreshRoutesEvent(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 添加routes</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> definitions 目标routes</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> aliveRouteMap 当前存活路由map</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createDefinitions</span><span class="params">(List&lt;RouteDefinition&gt; definitions, Map&lt;String, RouteDefinition&gt; aliveRouteMap)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 获取新添加的definitions</span></span><br><span class="line">            Set&lt;String&gt; aliveRouteIdSet = aliveRouteMap.keySet();</span><br><span class="line">            List&lt;RouteDefinition&gt; needCreateDefs =</span><br><span class="line">                    definitions</span><br><span class="line">                            .stream()</span><br><span class="line">                            .filter(route -&gt; !aliveRouteIdSet.contains(route.getId()))  <span class="comment">// 不存在与当前存活集合</span></span><br><span class="line">                            .collect(Collectors.toList());</span><br><span class="line">            doCreateDefinitions(needCreateDefs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 执行添加路由</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> needCreateDefs 需要新增的路由集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCreateDefinitions</span><span class="params">(List&lt;RouteDefinition&gt; needCreateDefs)</span> </span>&#123;</span><br><span class="line">            needCreateDefs.forEach(createDef -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.routeDefinitionRepository.save(Mono.just(createDef)).subscribe();</span><br><span class="line">                    log.info(<span class="string">"created route: &#123;&#125;"</span>, createDef.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    log.info(<span class="string">"create route &#123;&#125; fail"</span>, createDef.getId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 更新路由</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> definitions 目标routes</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> aliveRouteMap 当前存活路由map</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDefinitions</span><span class="params">(List&lt;RouteDefinition&gt; definitions, Map&lt;String, RouteDefinition&gt; aliveRouteMap)</span> </span>&#123;</span><br><span class="line">            Set&lt;String&gt; aliveRouteIdSet = aliveRouteMap.keySet();</span><br><span class="line">            List&lt;RouteDefinition&gt; needUpdateDefs =</span><br><span class="line">                    definitions</span><br><span class="line">                            .stream()</span><br><span class="line">                            .filter(route -&gt; aliveRouteIdSet.contains(route.getId())</span><br><span class="line">                                    &amp;&amp; !route.equals(aliveRouteMap.get(route.getId())))  <span class="comment">// 当前存活且与当前definition不同则为更新</span></span><br><span class="line">                            .collect(Collectors.toList());</span><br><span class="line">            doUpdateDefinitions(needUpdateDefs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 删除并重新创建路由实现更新</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * route repo无updater的结局方法</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> needUpdateDefs 需要更新route集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doUpdateDefinitions</span><span class="params">(List&lt;RouteDefinition&gt; needUpdateDefs)</span> </span>&#123;</span><br><span class="line">            needUpdateDefs.forEach(updateDefinition -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.routeDefinitionRepository</span><br><span class="line">                            .delete(Mono.just(updateDefinition.getId()))</span><br><span class="line">                            .subscribe();</span><br><span class="line">                    log.info(<span class="string">"removed old route(will be recreate): &#123;&#125;"</span>, updateDefinition.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    log.info(<span class="string">"can't clean route(will be create): &#123;&#125;"</span>, updateDefinition.getId());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.routeDefinitionRepository.save(Mono.just(updateDefinition)).subscribe();</span><br><span class="line">                    log.info(<span class="string">"updated route: &#123;&#125;"</span>, updateDefinition.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    log.info(<span class="string">"updated route &#123;&#125; fail"</span>, updateDefinition.getId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取当前存活的路由描述map</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> 当前存活的路由描述map</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Map&lt;String, RouteDefinition&gt; <span class="title">getAliveRouteMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> routeDefinitionRepository</span><br><span class="line">                    .getRouteDefinitions()</span><br><span class="line">                    .toStream()</span><br><span class="line">                    .collect(Collectors.toMap(RouteDefinition::getId, Function.identity()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 删除剔除的routes</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> targetDefIds 目标route id集合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> aliveRouteMap 当前存活的路由map</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeDefinitions</span><span class="params">(List&lt;String&gt; targetDefIds, Map&lt;String, RouteDefinition&gt; aliveRouteMap)</span> </span>&#123;</span><br><span class="line">            List&lt;String&gt; removedDefinitionIds =</span><br><span class="line">                    aliveRouteMap</span><br><span class="line">                            .keySet()</span><br><span class="line">                            .stream()</span><br><span class="line">                            .filter(routeId -&gt; !targetDefIds.contains(routeId)) <span class="comment">// 不存在于目标id集合判定为删除</span></span><br><span class="line">                            .collect(Collectors.toList());</span><br><span class="line">            doRemoveDefinitions(removedDefinitionIds);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 删除剔除的routes</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> removedDefinitionIds 需要被剔除的route id集合</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRemoveDefinitions</span><span class="params">(List&lt;String&gt; removedDefinitionIds)</span> </span>&#123;</span><br><span class="line">            removedDefinitionIds.forEach(removedId -&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>.routeDefinitionRepository</span><br><span class="line">                        .delete(Mono.just(removedId))</span><br><span class="line">                        .subscribe();</span><br><span class="line">                log.info(<span class="string">"removed route: &#123;&#125;"</span>, removedId);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 开启监听</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> applicationEventPublisher publisher instance</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.publisher = applicationEventPublisher;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ```  </span><br><span class="line">* DynamicRouteServiceListener</span><br><span class="line">    ```java</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 动态路由监听</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 添加对对应配置文件更新时的监听，实现动态路由刷新。一般的，为了保证</span></span><br><span class="line"><span class="comment">    * 仅在启动时注册指定的对应文件（通常这个文件也是动态配置，这里暂时没</span></span><br><span class="line"><span class="comment">    * 有实现当更换路由配置文件时的刷新）更新时对正在运行的路由信息进行刷</span></span><br><span class="line"><span class="comment">    * 新。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 该类主要实现yaml解析，并构建definition对象，对于具体的刷新逻辑</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> DynamicRouteServiceImpl</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Slf</span>4j</span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="meta">@RefreshScope</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicRouteServiceListener</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> DynamicRouteServiceImpl dynamicRouteService;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        NacosConfigManager nacosConfigManager;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> DynamicRoutingFileProperties dynamicRoutingFileProperties;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 添加配置文件更新监听</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dynamicRouteListener</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ConfigService configService = nacosConfigManager.getConfigService();</span><br><span class="line">                <span class="comment">// first process ed add listener</span></span><br><span class="line">                processConfigInfo(configService.getConfigAndSignListener(</span><br><span class="line">                        dynamicRoutingFileProperties.getDataId(),</span><br><span class="line">                        dynamicRoutingFileProperties.getGroupId(),</span><br><span class="line">                        dynamicRoutingFileProperties.getTimeout(),</span><br><span class="line">                        <span class="keyword">new</span> Listener()  &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(String configInfo)</span> </span>&#123;</span><br><span class="line">                                processConfigInfo(configInfo);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                ));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                log.error(<span class="string">"add config listener fail !!!"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 处理配置信息</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> configInfo 配置string</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processConfigInfo</span><span class="params">(String configInfo)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(configInfo)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 解析yaml文件获取路由定义</span></span><br><span class="line">            List&lt;RouteDefinition&gt; targetRouteDefinitions = getRouteDefinitionsByYaml(configInfo);</span><br><span class="line">            <span class="comment">// 更新路由信息</span></span><br><span class="line">            dynamicRouteService.refresh(targetRouteDefinitions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 通过yaml str解析出route定义</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> configInfo yaml str</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> RouteDefinition array</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> List&lt;RouteDefinition&gt; <span class="title">getRouteDefinitionsByYaml</span><span class="params">(String configInfo)</span> </span>&#123;</span><br><span class="line">            Yaml yaml = <span class="keyword">new</span> Yaml();</span><br><span class="line">            Map&lt;Object, Object&gt; document = yaml.load(configInfo);</span><br><span class="line">            List&lt;Map&lt;String, Object&gt;&gt; routeList = (List&lt;Map&lt;String, Object&gt;&gt;) document.get(<span class="string">"routes"</span>);</span><br><span class="line">            List&lt;RouteDefinition&gt; targetRouteDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(routeList.size());</span><br><span class="line">            <span class="keyword">for</span> (Map&lt;String, Object&gt; routeItem : routeList) &#123;</span><br><span class="line">                RouteDefinition routeDefinition = <span class="keyword">new</span> RouteDefinition();</span><br><span class="line">                routeDefinition.setId((String) routeItem.get(<span class="string">"id"</span>));</span><br><span class="line">                routeDefinition.setUri(URI.create((String) routeItem.get(<span class="string">"uri"</span>)));</span><br><span class="line">                List&lt;String&gt; predicateStrList = (List&lt;String&gt;) routeItem.get(<span class="string">"predicates"</span>);</span><br><span class="line">                List&lt;PredicateDefinition&gt; predicateDefinitions = predicateStrList.stream().map(PredicateDefinition::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">                routeDefinition.setPredicates(predicateDefinitions);</span><br><span class="line">                List&lt;String&gt; filterStrList = (List&lt;String&gt;) routeItem.get(<span class="string">"filters"</span>);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(filterStrList)) &#123;</span><br><span class="line">                    List&lt;FilterDefinition&gt; filterDefinitions = filterStrList.stream().map(FilterDefinition::<span class="keyword">new</span>).collect(Collectors.toList());</span><br><span class="line">                    routeDefinition.setFilters(filterDefinitions);</span><br><span class="line">                &#125;</span><br><span class="line">                Object orderObj = routeItem.get(<span class="string">"order"</span>);</span><br><span class="line">                <span class="keyword">int</span> order = Objects.isNull(orderObj) ? <span class="number">0</span> : (<span class="keyword">int</span>) orderObj;</span><br><span class="line">                routeDefinition.setOrder(order);</span><br><span class="line">                targetRouteDefinitions.add(routeDefinition);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> targetRouteDefinitions;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">            Long startTime = System.currentTimeMillis();</span><br><span class="line">            dynamicRouteListener();</span><br><span class="line">            Long completeTime = System.currentTimeMillis();</span><br><span class="line">            log.info(<span class="string">"dynamic router cost &#123;&#125;ms to initialization routes and registered configurer."</span>, completeTime - startTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置与填序"><a href="#配置与填序" class="headerlink" title="配置与填序"></a>配置与填序</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">crmCampusModule</span></span><br><span class="line">    <span class="attr">uri:</span> <span class="string">lb://campus</span></span><br><span class="line">    <span class="attr">predicates:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Path=/campus/crm/**</span></span><br></pre></td></tr></table></figure><p>uri使用lb走的是SCA的nacos naming，后面跟服务名称就好了，具体还有一个order参数，是用来标识路由顺序的，默认做了列表的填序，如果自己配置了order的话还是以自定义的order为主。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做一个分布式锁的通用starter</title>
      <link href="2020/08/22/%E5%81%9A%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E9%80%9A%E7%94%A8starter/"/>
      <url>2020/08/22/%E5%81%9A%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E9%80%9A%E7%94%A8starter/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>接上篇  <a href="https://noir-lattice.github.io/2020/07/19/%E7%BB%86%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">细谈分布式锁</a>, 实现通用的一个spring boot starter。</p><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><p>构建完成的项目包结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├─src</span><br><span class="line">    ├─main.java.com.noir.common.lock</span><br><span class="line">       │                          ├─annotation    ## 注解</span><br><span class="line">       │                          ├─aop           ## aop切面实现注解支持</span><br><span class="line">       │                          ├─excptions     ## 异常都在这里</span><br><span class="line">       │                          ├─impl       </span><br><span class="line">       │                          │  ├─factorys   ## 锁的工厂实现类</span><br><span class="line">       │                          │  └─locks      ## 锁的实现类</span><br><span class="line">       │                          └─properties    ## 中间件配置的封装</span><br><span class="line">       └─resources</span><br><span class="line">           └─META-INF</span><br></pre></td></tr></table></figure><h3 id="starter配置类"><a href="#starter配置类" class="headerlink" title="starter配置类"></a>starter配置类</h3><p>配置提供starter发现的META-INF/spring.factories</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.noir.common.LockStarterAutoConfiguration</span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.noir.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.noir.common.lock.properties.DLockProperties;</span><br><span class="line"><span class="keyword">import</span> com.noir.common.lock.properties.RedLockProperties;</span><br><span class="line"><span class="keyword">import</span> com.noir.common.lock.properties.RedisDLockProperties;</span><br><span class="line"><span class="keyword">import</span> com.noir.common.lock.properties.ZookeeperDLockProperties;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * starter配置启动类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 扫描了 &#123;<span class="doctag">@link</span> com.noir.common.lock&#125; 下的</span></span><br><span class="line"><span class="comment"> * 所有类进行初始化，包含aop，对应配置的工程类，</span></span><br><span class="line"><span class="comment"> * 对应中间件配置以及封装使用的service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 仅在 &#123;<span class="doctag">@code</span> locker.enabled=true&#125; 时有效</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 具体实现参考接口及拓展类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.DLockFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.LockableService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.ReentrantDLock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.noir.common.lock"</span>)</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"locker"</span>, value = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;DLockProperties<span class="class">.<span class="keyword">class</span>, <span class="title">RedisDLockProperties</span>.<span class="title">class</span>, <span class="title">RedLockProperties</span>.<span class="title">class</span>, <span class="title">ZookeeperDLockProperties</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LockStarterAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> RedisDLockProperties redisDLockProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> RedLockProperties redLockProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> ZookeeperDLockProperties zookeeperDLockProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"locker"</span>, value = <span class="string">"type"</span>, havingValue = <span class="string">"redis-expire"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonEXClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createRedissonClient(redisDLockProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"locker"</span>, value = <span class="string">"type"</span>, havingValue = <span class="string">"redis-get-set"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonGetSetClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createRedissonClient(redisDLockProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"locker"</span>, value = <span class="string">"type"</span>, havingValue = <span class="string">"red-lock"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;RedissonClient&gt; <span class="title">redissonRedLockClients</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redLockProperties.getClients().stream().map(<span class="keyword">this</span>::createRedissonClient).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"locker"</span>, value = <span class="string">"type"</span>, havingValue = <span class="string">"zookeeper"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZooKeeper <span class="title">zooKeeper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createZooKeeper(zookeeperDLockProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ZooKeeper <span class="title">createZooKeeper</span><span class="params">(ZookeeperDLockProperties zookeeperDLockProperties)</span> </span>&#123;</span><br><span class="line">        ZooKeeper zooKeeper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            zooKeeper = <span class="keyword">new</span> ZooKeeper(zookeeperDLockProperties.getAddress(), zookeeperDLockProperties.getTimeout(), event -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(Watcher.Event.KeeperState.SyncConnected==event.getState())&#123;</span><br><span class="line">                    <span class="comment">//如果收到了服务端的响应事件,连接成功</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            log.info(<span class="string">"【初始化ZooKeeper连接状态....】=&#123;&#125;"</span>, zooKeeper.getState());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">"【初始化ZooKeeper连接异常....】= &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zooKeeper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedissonClient <span class="title">createRedissonClient</span><span class="params">(RedisDLockProperties redisDLockProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (redisDLockProperties.getMode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"single"</span>:</span><br><span class="line">                <span class="keyword">return</span> redissonSingle(redisDLockProperties);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"cluster"</span>:</span><br><span class="line">                <span class="keyword">return</span> redissonCluster(redisDLockProperties);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sentinel"</span>:</span><br><span class="line">                <span class="keyword">return</span> redissonSentinel(redisDLockProperties);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单机模式 redisson 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedissonClient <span class="title">redissonSingle</span><span class="params">(RedisDLockProperties redisDLockProperties)</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        String node = redisDLockProperties.getSingle().getAddress();</span><br><span class="line">        node = node.startsWith(<span class="string">"redis://"</span>) ? node : <span class="string">"redis://"</span> + node;</span><br><span class="line">        SingleServerConfig serverConfig = config.useSingleServer()</span><br><span class="line">                .setAddress(node)</span><br><span class="line">                .setTimeout(redisDLockProperties.getSingle().getConnTimeout())</span><br><span class="line">                .setConnectionPoolSize(redisDLockProperties.getPool().getSize())</span><br><span class="line">                .setConnectionMinimumIdleSize(redisDLockProperties.getPool().getMinIdle());</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(redisDLockProperties.getPassword())) &#123;</span><br><span class="line">            serverConfig.setPassword(redisDLockProperties.getPassword());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群模式的 redisson 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedissonClient <span class="title">redissonCluster</span><span class="params">(RedisDLockProperties redisDLockProperties)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cluster redisProperties:"</span> + redisDLockProperties.getCluster());</span><br><span class="line"></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        String[] nodes = extractRedisAddressByString(redisDLockProperties.getCluster().getNodes());</span><br><span class="line"></span><br><span class="line">        ClusterServersConfig serverConfig = config.useClusterServers()</span><br><span class="line">                .addNodeAddress(nodes)</span><br><span class="line">                .setScanInterval(</span><br><span class="line">                        redisDLockProperties.getCluster().getScanInterval())</span><br><span class="line">                .setIdleConnectionTimeout(</span><br><span class="line">                        redisDLockProperties.getPool().getSoTimeout())</span><br><span class="line">                .setConnectTimeout(</span><br><span class="line">                        redisDLockProperties.getPool().getConnTimeout())</span><br><span class="line">                .setFailedAttempts(</span><br><span class="line">                        redisDLockProperties.getCluster().getFailedAttempts())</span><br><span class="line">                .setRetryAttempts(</span><br><span class="line">                        redisDLockProperties.getCluster().getRetryAttempts())</span><br><span class="line">                .setRetryInterval(</span><br><span class="line">                        redisDLockProperties.getCluster().getRetryInterval())</span><br><span class="line">                .setMasterConnectionPoolSize(redisDLockProperties.getCluster()</span><br><span class="line">                        .getMasterConnectionPoolSize())</span><br><span class="line">                .setSlaveConnectionPoolSize(redisDLockProperties.getCluster()</span><br><span class="line">                        .getSlaveConnectionPoolSize())</span><br><span class="line">                .setTimeout(redisDLockProperties.getTimeout());</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(redisDLockProperties.getPassword())) &#123;</span><br><span class="line">            serverConfig.setPassword(redisDLockProperties.getPassword());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哨兵模式 redisson 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedissonClient <span class="title">redissonSentinel</span><span class="params">(RedisDLockProperties redisDLockProperties)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sentinel redisProperties:"</span> + redisDLockProperties.getSentinel());</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line"></span><br><span class="line">        String[] nodes = extractRedisAddressByString(redisDLockProperties.getSentinel().getNodes());</span><br><span class="line"></span><br><span class="line">        SentinelServersConfig serverConfig = config.useSentinelServers()</span><br><span class="line">                .addSentinelAddress(nodes)</span><br><span class="line">                .setMasterName(redisDLockProperties.getSentinel().getMaster())</span><br><span class="line">                .setReadMode(ReadMode.SLAVE)</span><br><span class="line">                .setFailedAttempts(redisDLockProperties.getSentinel().getFailMax())</span><br><span class="line">                .setTimeout(redisDLockProperties.getTimeout())</span><br><span class="line">                .setMasterConnectionPoolSize(redisDLockProperties.getPool().getMasterConnectionPoolSize())</span><br><span class="line">                .setSlaveConnectionPoolSize(redisDLockProperties.getPool().getSlaveConnectionPoolSize());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(redisDLockProperties.getPassword())) &#123;</span><br><span class="line">            serverConfig.setPassword(redisDLockProperties.getPassword());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] extractRedisAddressByString(String nodeStr) &#123;</span><br><span class="line">        String[] nodes = nodeStr.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(nodes)</span><br><span class="line">                        .map(str -&gt; str.startsWith(<span class="string">"redis://"</span>) ? str : <span class="string">"redis://"</span> + str)</span><br><span class="line">                        .toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><ul><li><p>提供DLockFactory暴露给外部，实现一定的灵活性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.noir.common.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DLock工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提供了DLock的工厂接口，为了更通用并可拓展，</span></span><br><span class="line"><span class="comment"> * 对 &#123;<span class="doctag">@link</span> ReentrantDLock&#125; 进行了擦除，</span></span><br><span class="line"><span class="comment"> * 在进行具体自定义拓展时，建议继承ReentrantDLock</span></span><br><span class="line"><span class="comment"> * 以实现可重入支持。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 具体工厂实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.impl.factorys.RedisSetNXExpireLockFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.impl.factorys.RedisSetNXGetSetLockFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.impl.factorys.RedLockFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.impl.factorys.ZookeeperLockFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DLockFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 锁名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 锁对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lock <span class="title">getLock</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 锁名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire 过去时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 锁对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lock <span class="title">getLock</span><span class="params">(String name, <span class="keyword">long</span> expire, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供LockableService作为方便使用Bean接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.noir.common.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具有加锁逻辑的服务接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提供了lambda表达式的上锁支持，标定锁名称</span></span><br><span class="line"><span class="comment"> * 与对应的Callable或者Runnable即可实现对</span></span><br><span class="line"><span class="comment"> * 块级逻辑的资源锁定，对于多个资源的锁定可以</span></span><br><span class="line"><span class="comment"> * 通过多级嵌套进行实现，同样的，因为默认实现</span></span><br><span class="line"><span class="comment"> * 的工程均实现了可重入接口 &#123;<span class="doctag">@link</span> ReentrantDLock&#125;</span></span><br><span class="line"><span class="comment"> * 在未使用自定义的DLockFactory时均可重入</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 具体的实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.impl.LockableServiceImpl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LockableService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key进行加锁, 执行callable任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      加锁的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable 执行的操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;      callable任务返回的结果类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> callable任务返回的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception callable任务执行过程中产生的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">lockAndExecute</span><span class="params">(String key, Callable&lt;T&gt; callable)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key进行加锁，执行runnable任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      加锁的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable 执行的操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception runnable任务执行过程中产生的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockAndExecute</span><span class="params">(String key, Runnable runnable)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供可重入锁的基础类支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.noir.common.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可重入DLock拓展</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用thread local实现锁状态标定，如拓展实现</span></span><br><span class="line"><span class="comment"> * 自定义的锁实现，请务必在解锁后 &#123;<span class="doctag">@link</span> ReentrantDLock#exit(String)&#125;</span></span><br><span class="line"><span class="comment"> * 以保证状态的清除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提供的四种实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.impl.locks.RedLockWrapper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.impl.locks.RedisSetNXGetSetLock</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.impl.locks.RedisSetNXExpireLock</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.impl.locks.ZookeeperLock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantDLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;List&lt;String&gt;&gt; localLocks = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEntered</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; locks = localLocks.get();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(locks)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locks.contains(lockName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; locks = localLocks.get();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(locks)) &#123;</span><br><span class="line">            localLocks.set(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            locks = localLocks.get();</span><br><span class="line">        &#125;</span><br><span class="line">        locks.add(lockName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; locks = localLocks.get();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(locks)) &#123;</span><br><span class="line">            locks.remove(lockName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实现aop注解支持"><a href="#实现aop注解支持" class="headerlink" title="实现aop注解支持"></a>实现aop注解支持</h3><ul><li><p>定义一个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.noir.common.lock.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解式分布式锁支持</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在标定的方法执行结束后将自动释放锁，同样的，</span></span><br><span class="line"><span class="comment"> * 支持可重入意味着可以嵌套使用而不发生死锁。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ElementType.ANNOTATION_TYPE&#125;，</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Inherited</span>&#125;</span></span><br><span class="line"><span class="comment"> * 这意味着这同样是一个元注解，可以像普通使用</span></span><br><span class="line"><span class="comment"> * Spring annotation一样将多个注解标定到一</span></span><br><span class="line"><span class="comment"> * 个通用的注解上并使用</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.core.annotation.AliasFor&#125;</span></span><br><span class="line"><span class="comment"> * 来指定annotation并将value标定merge进来。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ElementType.TYPE&#125;</span></span><br><span class="line"><span class="comment"> * 而对于标定在class上的注解，都将会尝试解析</span></span><br><span class="line"><span class="comment"> * 锁并在其下的方法执行过程中上锁，我认为这不</span></span><br><span class="line"><span class="comment"> * 是一个好方法，对于整体的逻辑和类内部的接口</span></span><br><span class="line"><span class="comment"> * 设计都是一个限制，但我还是提供了，请注意。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 同所有Spring AOP标定的注解一样，他可能存</span></span><br><span class="line"><span class="comment"> * 在失效的场景，即内部互相调用时会失去作用，</span></span><br><span class="line"><span class="comment"> * 这会带来额外的心智负担，如果你的团队对于这</span></span><br><span class="line"><span class="comment"> * 些方面并不熟悉，请更多使用</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> com.noir.common.lock.LockableService&#125;</span></span><br><span class="line"><span class="comment"> * or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> com.noir.common.lock.DLockFactory&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果还有疑问及迷惑，可以查看具体的aop实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.aop.DLockAnnotationAdvice</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.aop.DLockClassAnnotationAdvisor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.aop.DLockMethodAnnotationAdvisor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DLock &#123;</span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeOutSecond</span><span class="params">()</span> <span class="keyword">default</span> 30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于类上标记注解的切面支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.noir.common.lock.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.noir.common.lock.annotation.DLock;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.aop.Advice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.support.AbstractPointcutAdvisor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.support.annotation.AnnotationMatchingPointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类注解advisor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用于标定类上有 &#123;<span class="doctag">@link</span> com.noir.common.lock.annotation.DLock&#125;</span></span><br><span class="line"><span class="comment"> * 的切点与对应AnnotationAdvice</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.aop.DLockAnnotationAdvice</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLockClassAnnotationAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DLockAnnotationAdvice dLockAnnotationAdvice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationMatchingPointcut(DLock<span class="class">.<span class="keyword">class</span>, <span class="title">null</span>, <span class="title">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dLockAnnotationAdvice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于方法上标记注解的切面支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.noir.common.lock.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.noir.common.lock.annotation.DLock;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.aop.Advice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.support.AbstractPointcutAdvisor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.support.annotation.AnnotationMatchingPointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法注解advisor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用于标定方法上有 &#123;<span class="doctag">@link</span> com.noir.common.lock.annotation.DLock&#125;</span></span><br><span class="line"><span class="comment"> * 的切点与对应AnnotationAdvice</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.aop.DLockAnnotationAdvice</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLockMethodAnnotationAdvisor</span> <span class="keyword">extends</span> <span class="title">AbstractPointcutAdvisor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DLockAnnotationAdvice dLockAnnotationAdvice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pointcut <span class="title">getPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationMatchingPointcut(<span class="keyword">null</span>, DLock<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Advice <span class="title">getAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dLockAnnotationAdvice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体实现的advice</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.noir.common.lock.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.noir.common.lock.DLockFactory;</span><br><span class="line"><span class="keyword">import</span> com.noir.common.lock.annotation.DLock;</span><br><span class="line"><span class="keyword">import</span> com.noir.common.lock.excptions.ErrorParseLockKey;</span><br><span class="line"><span class="keyword">import</span> com.noir.common.lock.excptions.TryLockFailException;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.expression.BeanFactoryResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.LocalVariableTableParameterNameDiscoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AnnotatedElementUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ParseException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.common.TemplateParserContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的注解解析advice</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现拓展了 &#123;<span class="doctag">@link</span> MethodInterceptor&#125; 以支持</span></span><br><span class="line"><span class="comment"> * 对于方法的上锁增强，通过查找方法及其类上的注解对</span></span><br><span class="line"><span class="comment"> * 相应资源进行上锁或等待。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 拓展提供了对方法参数的SpEL解析，可以通过如</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@DLock</span>("#&#123;#xxx&#125;")&#125; 来获取传入参</span></span><br><span class="line"><span class="comment"> * 数的解析与资源的上锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 资源锁依赖 &#123;<span class="doctag">@link</span> DLockFactory&#125;来获取实现了</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Lock&#125; 的实例并对资源进行后续操作，如有</span></span><br><span class="line"><span class="comment"> * 疑惑可看工厂类的接口及其下实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.noir.common.lock.DLockFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLockAnnotationAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DLockFactory lockFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method params discover</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalVariableTableParameterNameDiscoverer parameterNameDiscoverer = <span class="keyword">new</span> LocalVariableTableParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doLock(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">doLock</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] args = invocation.getArguments();</span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        Class&lt;?&gt; clz = method.getDeclaringClass();</span><br><span class="line"></span><br><span class="line">        DLock dLock = AnnotatedElementUtils.findMergedAnnotation(clz, DLock<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        DLock methodDLock = AnnotatedElementUtils.findMergedAnnotation(method, DLock<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(methodDLock)) &#123;</span><br><span class="line">            dLock = methodDLock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> dLock != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建解析器</span></span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        <span class="comment">// 创建上下文</span></span><br><span class="line">        StandardEvaluationContext ctx = creteCtx(method, args);</span><br><span class="line"></span><br><span class="line">        List&lt;Lock&gt; locks = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String lockResourceEL : dLock.value()) &#123;</span><br><span class="line">            <span class="comment">// el parse</span></span><br><span class="line">            String lockResource = parseKey(parser, ctx, lockResourceEL);</span><br><span class="line">            locks.add(lockFactory.getLock(lockResource));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Lock lock:locks) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!lock.tryLock(dLock.timeOutSecond(), TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TryLockFailException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Lock lock:locks) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SpEL解析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">parseKey</span><span class="params">(ExpressionParser parser, StandardEvaluationContext ctx, String key)</span> <span class="keyword">throws</span> ErrorParseLockKey </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key)) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parser.parseExpression(key, <span class="keyword">new</span> TemplateParserContext()).getValue(ctx, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ErrorParseLockKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化解析上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StandardEvaluationContext <span class="title">creteCtx</span><span class="params">(Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        String[] paraNameArr = parameterNameDiscoverer.getParameterNames(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//SpEL上下文</span></span><br><span class="line">        StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        <span class="comment">//把方法参数放入SpEL上下文中</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(paraNameArr)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paraNameArr.length; i++) &#123;</span><br><span class="line">                context.setVariable(paraNameArr[i], args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// bean ctx support</span></span><br><span class="line">        context.setBeanResolver(<span class="keyword">new</span> BeanFactoryResolver(applicationContext));</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实现默认实现与相应的配置化"><a href="#实现默认实现与相应的配置化" class="headerlink" title="实现默认实现与相应的配置化"></a>实现默认实现与相应的配置化</h3><p>在上面所说的项目结构指定的包中，几种实现更多是基于上篇所述，有兴趣的可以移步至github: <a href="https://github.com/noir-lattice/spring-boot-distributed-lock-starter" target="_blank" rel="noopener">spring-boot-distributed-lock-starter</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> zookeeper </tag>
            
            <tag> 分布式资源抢占 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细谈分布式锁</title>
      <link href="2020/07/19/%E7%BB%86%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>2020/07/19/%E7%BB%86%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>锁是对于资源的生产消费，占用与解除占用来说无法逃避的话题，而分布式的依赖中间件的锁是咱今天要说的。<br>不同以往的是，咱们今天不老生常谈，原理基础大多博文其实这一块都说明的很好了，咱们今天说说存在的问题和对于问题解决的折中方案。</p><h3 id="getSet-redis锁"><a href="#getSet-redis锁" class="headerlink" title="getSet redis锁"></a>getSet redis锁</h3><p>不说那么多，先读下代码，咱们再来分析问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(RedisLock<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SLEEP_MILLIS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redisson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String nameSpace;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long lockValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁失效时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lockExpiresMilliseconds;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(RedissonClient redisson, String nameSpace, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认30分钟</span></span><br><span class="line">        <span class="keyword">this</span>(redisson, nameSpace, name, <span class="number">30</span>, TimeUnit.MINUTES, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLock</span><span class="params">(RedissonClient redisson, String nameSpace, String name, <span class="keyword">long</span> expire, TimeUnit unit, <span class="keyword">int</span> sleepMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisson = redisson;</span><br><span class="line">        <span class="keyword">this</span>.nameSpace = nameSpace;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.lockExpiresMilliseconds = unit.toMillis(expire);</span><br><span class="line">        <span class="keyword">this</span>.DEFAULT_SLEEP_MILLIS = sleepMillis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String lockKey = getLockKey();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> deadline = System.currentTimeMillis() + unit.toMillis(time);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (deadline &gt;= System.currentTimeMillis()) &#123;</span><br><span class="line">            Long serverTime = getServerTime();</span><br><span class="line">            lockValue = serverTime + lockExpiresMilliseconds;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (redisson.getBucket(lockKey).trySet(lockValue)) &#123;</span><br><span class="line">                log.info(lockKey + <span class="string">" locked by getSet"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Long currentValue = (Long) redisson.getBucket(lockKey).get();</span><br><span class="line">            <span class="comment">//判断锁是否失效</span></span><br><span class="line">            <span class="keyword">if</span> (currentValue != <span class="keyword">null</span> &amp;&amp; currentValue &lt; serverTime) &#123;</span><br><span class="line">                Long oldValueStr = (Long) redisson.getBucket(lockKey).getAndSet(lockValue);</span><br><span class="line">                <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValue)) &#123;</span><br><span class="line">                    log.info(<span class="string">"locked by getSet"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(DEFAULT_SLEEP_MILLIS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String lockKey = getLockKey();</span><br><span class="line">        Long currValue = (Long) redisson.getBucket(lockKey).get();</span><br><span class="line">        <span class="keyword">if</span> (currValue != <span class="keyword">null</span> &amp;&amp; currValue.equals(lockValue)) &#123;</span><br><span class="line">            log.info(lockKey + <span class="string">" unlock"</span>);</span><br><span class="line">            redisson.getBucket(lockKey).delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getLockKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nameSpace + <span class="string">":"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取服务器时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">getServerTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，这是一个getSet标记时间的redis锁的实现：<br><img src="getSetLock.png" alt="getSet lock">  </p><p>这里咱们很容易产生以下的思考：</p><ul><li>expire设置多大呢？</li><li>过大再应用获取资源后挂掉该资源<strong>长期不可用</strong>咋办？</li><li>过小无法cover业务执行时间导致<strong>无法保证资源独占</strong>怎们办？</li><li>设置的不大不小万一有个rpc服务间调用因为网络的问题阻塞正好在锁过期后完成，且已有线程抢占获取该锁时，因为没有锁id，<strong>释放了其它线程的锁</strong>怎么办？</li></ul><p>这还只是基于代码层面的思考，我们继续往下想：</p><ul><li>如果我们用的是主从架构，在同步时另一线程再令一节点抢占是否会获取锁？</li><li>为了解决该问题我们需要同时指定所有的getSet去master来保证原子性，而本来我们的操作算作是CAS做了不断的重试，在这类业务聚集时，咱们就相当于在对master做ddos</li><li>那是不是意味着咱们必须做分片？做完分片完事存在主备是否依旧要把getSet打在同一服务上？</li></ul><p>上面这块的锁是在阿里云的哨兵集群redis中跑的，锁过期给的30分钟。</p><h3 id="setNx-redis锁"><a href="#setNx-redis锁" class="headerlink" title="setNx redis锁"></a>setNx redis锁</h3><p>老规矩，show me the code:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RedisLock</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key redis key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expire 过期时间，单位秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true:加锁成功，false，加锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">int</span> expire)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisService redisService = SpringUtils.getBean(RedisService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">long</span> status = redisService.setnx(key, <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">1</span>) &#123;</span><br><span class="line">            redisService.expire(key, expire);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        RedisService redisService = SpringUtils.getBean(RedisService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        redisService.del(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这逻辑简单到不想画图，但是这个代码说是问题最大的也不为过，首先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">int</span> expire)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RedisService redisService = SpringUtils.getBean(RedisService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">long</span> status = redisService.setnx(key, <span class="string">"1"</span>);</span><br><span class="line">    <span class="comment">// &lt;-------------------------------在这停顿</span></span><br><span class="line">    <span class="keyword">if</span>(status == <span class="number">1</span>) &#123;</span><br><span class="line">        redisService.expire(key, expire);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里挂掉，这个资源永远锁死，你永远不知道你的docker会啥时候把你的容器秒了，可能是超出了分配内存，可能是滚动更新，你的服务能完整的跑完代码才是一件幸运的事情。  </p><p>我们改做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisService.evel(<span class="string">"set "</span> + key + <span class="string">" 1 NX PX "</span> + expire);</span><br></pre></td></tr></table></figure><p>保证原子性</p><p>再者,我们为了解锁的安全， 要添加锁id:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Long&gt; lid = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key, <span class="keyword">int</span> expire)</span> </span>&#123;</span><br><span class="line">    RedisService redisService = SpringUtils.getBean(RedisService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    lid.set(IdUtils.genId());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> status = redisService.evel(<span class="string">"set "</span> + key + <span class="string">" "</span> + lid.get() + <span class="string">" NX PX "</span> + expire);</span><br><span class="line">    <span class="keyword">return</span> status == lid.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    RedisService redisService = SpringUtils.getBean(RedisService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> olid = redisService.get(key, <span class="string">"0"</span>);</span><br><span class="line">    <span class="comment">// &lt;------------------------------- 在这停顿</span></span><br><span class="line">    <span class="keyword">if</span> (olid == lid.get()) &#123;</span><br><span class="line">      redisService.del(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们为了保证解锁的原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisService.evel(<span class="string">"if redis.call('get', '"</span> + key + <span class="string">"') == "</span> + lid.get() + <span class="string">" then return redis.call('del', '"</span> + key + <span class="string">"'); end return 0"</span>);</span><br></pre></td></tr></table></figure><p>一个逻辑较为简单、原子性都还行且没有大量getSet存在redis锁就成了，但是仅仅也只是代码上看。</p><p>咱们从整体架构上呢？ 依然没有解决可用性的问题，如果只依赖单点的redis不存在问题但是可用性不高，如果使用主从则同步会发生问题，必须将读写打在同一台上。</p><p>更扯淡和令人难受的是，某些云厂商的托管redis不给你用evel。</p><h3 id="redlock方案"><a href="#redlock方案" class="headerlink" title="redlock方案"></a>redlock方案</h3><p>redis社区推荐的方案是redlock，为了保证redis锁服务的高可用且资源的隔离，我们部署N个redis单点，这些节点间不存在主从复制，我们确保将在N个实例上使用与单例redis下同样的方法<br>获取锁和释放锁。</p><p>而当获取一个资源的锁时：</p><ul><li>获取当前时间</li><li>依次尝试从N个实例下获取锁，而每个单例锁获取都有个超时时间，这个超时时间用于当某个节点挂掉时不至于等待过长的时间来获取该实例的锁，可以快速的跳到下个实例<br>进行尝试</li><li>当获取超过半数实例的锁时才会真正的获得资源</li><li>当没有获取半数实例的锁的情况下（过半数失败）释放以获得所有的锁</li></ul><p>而具体的实现方案redisson已经做好了封装，详细可看：<br><a href="https://github.com/redisson/redisson/wiki/8.-Distributed-locks-and-synchronizers" target="_blank" rel="noopener">Distributed locks and synchronizers</a></p><p>缺点就是为了获取各实例的锁所消耗的时间，以及你为了买各个实例所花掉的钱。。。。。</p><h3 id="zookeeper方案"><a href="#zookeeper方案" class="headerlink" title="zookeeper方案"></a>zookeeper方案</h3><p>其实我很喜欢这个方案，zk天生就是做这玩意的料，做个可重入、公平锁简单可靠，而临时节点基于会话，对于应用程序错误导致资源的释放不依赖过期判断。</p><p>但是毕竟是引入的中间件，而且其确实有一定的成本和风险（CP系统的可用性），在场景上我们要有些取舍。</p><p>利用名称唯一实现独占锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String root = <span class="string">"/locks"</span>;<span class="comment">//根</span></span><br><span class="line">    <span class="keyword">private</span> String lockName;<span class="comment">//竞争资源的标志</span></span><br><span class="line">    <span class="keyword">private</span> String myZnode;<span class="comment">//当前锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Exception&gt; exception = <span class="keyword">new</span> ArrayList&lt;Exception&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建分布式锁,使用前请确认config配置的zookeeper服务可用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 127.0.0.1:2181</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 竞争资源标志,lockName中不能包含单词lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZookeeperLock</span><span class="params">(String config, String lockName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockName = lockName;</span><br><span class="line">        <span class="comment">// 创建一个与服务器的连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(config, sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            Stat stat = zk.exists(root, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(stat == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 创建根节点</span></span><br><span class="line">                zk.create(root, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            exception.add(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            exception.add(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            exception.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exception.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(exception.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!tryLock()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(<span class="string">"您的操作太频繁，请稍后再试"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myZnode = zk.create(root + <span class="string">"/"</span> + lockName, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk.delete(myZnode, -<span class="number">1</span>);</span><br><span class="line">            myZnode = <span class="keyword">null</span>;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整一个公平锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String root = <span class="string">"/locks"</span>;<span class="comment">//根</span></span><br><span class="line">    <span class="keyword">private</span> String lockName;<span class="comment">//竞争资源的标志</span></span><br><span class="line">    <span class="keyword">private</span> String waitNode;<span class="comment">//等待前一个锁</span></span><br><span class="line">    <span class="keyword">private</span> String myZnode;<span class="comment">//当前锁</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;<span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Exception&gt; exception = <span class="keyword">new</span> ArrayList&lt;Exception&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建分布式锁,使用前请确认config配置的zookeeper服务可用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 127.0.0.1:2181</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName 竞争资源标志,lockName中不能包含单词lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributedLock</span><span class="params">(String config, String lockName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockName = lockName;</span><br><span class="line">        <span class="comment">// 创建一个与服务器的连接</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(config, sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            Stat stat = zk.exists(root, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(stat == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 创建根节点</span></span><br><span class="line">                zk.create(root, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            exception.add(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            exception.add(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            exception.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zookeeper节点的监视器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.latch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exception.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(exception.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.tryLock())&#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" "</span> +myZnode + <span class="string">" get lock true"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                waitForLock(waitNode, sessionTimeout);<span class="comment">//等待锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String splitStr = <span class="string">"_lock_"</span>;</span><br><span class="line">            <span class="keyword">if</span>(lockName.contains(splitStr))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> LockException(<span class="string">"lockName can not contains \\u000B"</span>);</span><br><span class="line">            <span class="comment">//创建临时子节点</span></span><br><span class="line">            myZnode = zk.create(root + <span class="string">"/"</span> + lockName + splitStr, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            System.out.println(myZnode + <span class="string">" is created "</span>);</span><br><span class="line">            <span class="comment">//取出所有子节点</span></span><br><span class="line">            List&lt;String&gt; subNodes = zk.getChildren(root, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//取出所有lockName的锁</span></span><br><span class="line">            List&lt;String&gt; lockObjNodes = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String node : subNodes) &#123;</span><br><span class="line">                String _node = node.split(splitStr)[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(_node.equals(lockName))&#123;</span><br><span class="line">                    lockObjNodes.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(lockObjNodes);</span><br><span class="line">            System.out.println(myZnode + <span class="string">"=="</span> + lockObjNodes.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(myZnode.equals(root+<span class="string">"/"</span>+lockObjNodes.get(<span class="number">0</span>)))&#123;</span><br><span class="line">                <span class="comment">//如果是最小的节点,则表示取得锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是最小的节点，找到比自己小1的节点</span></span><br><span class="line">            String subMyZnode = myZnode.substring(myZnode.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>);</span><br><span class="line">            waitNode = lockObjNodes.get(Collections.binarySearch(lockObjNodes, subMyZnode) - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.tryLock())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> waitForLock(waitNode,time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">waitForLock</span><span class="params">(String lower, <span class="keyword">long</span> waitTime)</span> <span class="keyword">throws</span> InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        Stat stat = zk.exists(root + <span class="string">"/"</span> + lower,<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//判断比自己小一个数的节点是否存在,如果不存在则无需等待锁,同时注册监听</span></span><br><span class="line">        <span class="keyword">if</span>(stat != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" waiting for "</span> + root + <span class="string">"/"</span> + lower);</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.latch.await(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"unlock "</span> + myZnode);</span><br><span class="line">            zk.delete(myZnode,-<span class="number">1</span>);</span><br><span class="line">            myZnode = <span class="keyword">null</span>;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(String e)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LockException</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更多工程上的支持"><a href="#更多工程上的支持" class="headerlink" title="更多工程上的支持"></a>更多工程上的支持</h3><p>无论是redis或者zk的DLock实现，对于工程上我们都有更多的需求：</p><ul><li>可重入锁实现</li><li>锁扩散策略</li><li>基于注解和aop的易用性支持等</li></ul><p>咱们将在后续慢慢补完</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> zookeeper </tag>
            
            <tag> 分布式资源抢占 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊JVM</title>
      <link href="2020/06/15/%E8%81%8A%E8%81%8AJVM/"/>
      <url>2020/06/15/%E8%81%8A%E8%81%8AJVM/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-Virtual-Machine"><a href="#Java-Virtual-Machine" class="headerlink" title="Java Virtual Machine"></a>Java Virtual Machine</h2><p>对于java虚拟机咱们写是需要专门写一篇来做下知识梳理的，将从以下各点内容铺开叙述JVM的结构与机制：</p><ul><li>内存结构</li><li>Garbage Collection</li><li>JIT(Just in Time)</li><li>AOT(Ahead on Time)</li><li>ClassLoader</li></ul><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>对于一个虚拟机架构的语言引擎，在启动时已经按照一定的方式将内存分类分区进行了调整。而对于JVM来说，内存结构分为6块，其结构如下图：<br><img src="ms.png" alt="内存结构"><br>包括公共共享的堆与方法区与线程内的程序计数器、虚拟机栈和本地方法栈  </p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器标记当前进程序进程执行字节码的地址，分支、循环、跳转、异常处理与线程恢复等功能都依赖其完成。注意区分该处的程序计数器与操作系统的进程内的计数器，该处的程序计数器供给java线程使用。而对于Native方法不由JVM托管，故执行Native方法不需要PC寄存器。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>为本地方法服务。需要理解的是，执行其实还是操作系统在执行，JVM的本地方法栈只对方法压栈与出栈。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>FIFO的策咯用栈来表示再合适不过了，在计算机系统中常用入栈/出栈来实现方法的调用/返回。在JVM中，将方法的局部变量表、操作数栈、动态链接和方法的返回构造成一个栈帧，并对其调用进行不断的压栈与出栈操作。 </p><p>栈内与代码执行关系如下图：<br><img src="vmstack.gif" alt="vmstack"><br>我们可以看到所有的方法执行都是入栈/出栈的操作，那么一个递归没写出口会爆栈就是上图这个栈爆了。    </p><p>而压入栈的每个栈帧记录着方法的：</p><ul><li><p>局部变量表: 用于存放方法的参数和和方法内定义的局部变量的的存储空间。在编译时，已经确认好改块内存区域的大小。在运行时，改变量表默认0号位置存放当前对象的指针（this）。  </p></li><li><p>操作数栈: 该块内存同局部变量表，在编译时以确定大小。通过压栈/出栈实现计算。 </p></li><li><p>动态链接: 当执行过程中需要调用一个方法，需要使用其名字（符号引用）找到对应的类和方法（直接引用），在运行时对符号引用解析成直接引用就叫动态链接。  </p></li><li><p>返回地址: 方法结束后需要返回到指定的位置，比如正常返回结果后要回到其被调用的赋值语句、异常退出后要回到被调用的catch语句以确保程序继续运行。  </p></li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。这个区域是用来存放对象实例的，几乎所有对象实例都会在这里分配内存。内内部的内存布局为GC的分代算法提供支持，具体内容由GC展开。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>属于共享内存区域，存储描述类信息、常量、静态变量和JIT后的代码。</p><h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><p>作为一个高级语言，不写析构和手动del是java能提升开发效率与降低开发人员门槛的重要特性，必然的，GC就是不得不说与不得不理解的一个东西。<br>本文将从以下几个问题来说明JVM的GC:</p><ul><li>怎么判断是不是垃圾</li><li>如何做垃圾处理</li><li>如何做垃圾分类  </li></ul><h3 id="是不是垃圾"><a href="#是不是垃圾" class="headerlink" title="是不是垃圾"></a>是不是垃圾</h3><p>  To Be or Not to Be?<br>  如何智能的判断当前内存里面的东西是不是死了，这是一个令人困扰的事情。在C++11以后我们可以通过显示的声明shared_ptr和week_ptr来实现基于引用计数的GC(Reference Counting GC)，令人兴奋的是引用计数非常便于理解，当有引用添加时计数器+1，当引用失效时计数器-1，在计数器发现引用次数为0时内存数据被销毁，而相互引用使用弱引用week_ptr来防止相互依赖的对象内存永远不会被销毁导致的内存泄漏。这个实现优雅而实时，不用担心GC工作太久带来的时停，缺点就是需要显示的声明强弱引用，而java作为<em>友好</em>的工程语言，所以自然不会用这种方式。  </p><p>  JVM先将内存分配管理交由虚拟机，再通过对栈内引用进行tracing，在栈内引用的对象链上的就是可达的，反之不可达。<br>  <img src="tracing.png" alt="tracing"></p><h3 id="如何做垃圾处理"><a href="#如何做垃圾处理" class="headerlink" title="如何做垃圾处理"></a>如何做垃圾处理</h3><p>对于Reference Counting GC来说垃圾回收是瞬时且不中断的，不需要进行更多的设计。而基于tracing的则需要有独立的GC线程对内存区域进行扫描，那么扫描后如何进行清理呢？</p><h4 id="标记-删除"><a href="#标记-删除" class="headerlink" title="标记-删除"></a>标记-删除</h4><p>tracing后标记可达后，简单的将不可达的内存空间清空。<br><img src="tag-remove.png" alt="tag-remove">  </p><h4 id="标记-压缩"><a href="#标记-压缩" class="headerlink" title="标记-压缩"></a>标记-压缩</h4><p>tracing后标记可达后，将可达的内存移动压缩至内存一侧，减少内存碎片。<br><img src="tag-zip.png" alt="tag-zip"></p><h4 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h4><p>由两块同样大小的内存组成，将标记可达的内存按顺序复制到另一块内存，在启用改内存后清空原内存空间。<br><img src="tag-copy.png" alt="tag-copy"></p><h3 id="如何做垃圾分类"><a href="#如何做垃圾分类" class="headerlink" title="如何做垃圾分类"></a>如何做垃圾分类</h3><p>JVM通过将对象存活周期做划分，将其分代回收来减少扫描压力。在JVM的堆中，将内存分带划分为以下部分<br><img src="heap.png" alt="heap"><br>对于GC，我们将从年轻代空间（包括 Eden 和 Survivor 区域）回收内存称为 Minor GC;将老年代的GC（伴随一次Minor GC）称为Full GC（或 Major GC）。</p><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>新生的对象存放在这里哦。而新生代占总内存的1/3，其中又可以详细分为一个Eden和两个Survivor。</p><h5 id="Eden"><a href="#Eden" class="headerlink" title="Eden"></a>Eden</h5><p>伊甸区，顾名思义，是新生的对象存放的地方，占总新生代的4/5。在GC发生后，一块Eden和一块正在使用的Survivor一齐进行标记-复制，将存活的对象复制到另一块Survivor中并将当前Eden和Survivor清空，可以看出，在默认的比例中，每次GC后新生代中的存活对象不会超过10%（一块Survivor），而超过Survivor的会交由老年代分配担保。</p><h5 id="Survivor"><a href="#Survivor" class="headerlink" title="Survivor"></a>Survivor</h5><p>当Eden区GC后幸存的对象会移动到Survivor区。Survivor区有两个，每个占新生代的1/10。两块Survivor进行标记-复制的回收策略，所以真实可用的只有其中的一块。</p><h5 id="新生代GC时"><a href="#新生代GC时" class="headerlink" title="新生代GC时"></a>新生代GC时</h5><p>Survivor Form和Eden中的对象会进行标记复制：<br><img src="yong-gc-before.png" alt="yong-gc-before"><br>复制完成后Survivor Form和Survivor To指针会互换：<br><img src="yong-gc-after.png" alt="yong-gc-after"><br>而当form和survivor中的存活对象大于to可容纳的对象空间时，就需要将剩余的对象放入老年带中，即老年代要进行分配担保。而分配担保是要在老年代拥有空余的空间的前提下进行的，而又因为每次存活下来的对象数量不可预知，所以取<em>每次GC后晋升至老年带的对象数量的平均作为参考</em>，从概率上来看，陡然激增对象是很少发生的，所以基本上这个参考的值做判断没有问题。那么我们可以总结出分配担保的流程如下：</p><ul><li>form和survivor中的存活对象大于to可容纳的对象空间</li><li>判断每次晋升的对象数量均值与老年带剩余空间比较，若大于该空间，则触发Full GC,否则继续</li><li>将对象尝试分配至老年带，成功则结束，失败则触发Full GC</li></ul><h4 id="老年带"><a href="#老年带" class="headerlink" title="老年带"></a>老年带</h4><p>老年代认为对象存活率高，不需要时常GC，故而一般使用标记-删除和标记-压缩。</p><h4 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h4><p>java8已经被删除了哦，这部分是存放类信息，已经移到Metadata里了哦。（至于说Method area，这个指的是概念而不是实现）</p><h2 id="JIT-Just-in-Time"><a href="#JIT-Just-in-Time" class="headerlink" title="JIT(Just in Time)"></a>JIT(Just in Time)</h2><p>对于VM来说，interpreter是最简单的，但是JVM可不是单单一个解释器就搞定了。其实现了JIT编译(just-in-time compilation)即即时编译，什么意思呢？<br>JVM判定热点代码，在另外的进程将热点代码从字节码编译成机器码，而在后续的热点代码执行则跳过解释器直接执行机器码来达到性能优化。<br>我们可以通过流程图理解<br><img src="jit-flow.png" alt="jit-flow"><br>在程序运行环境中内存资源限制较大时，可以使用解释执行节约内存（因为机器码会被缓存在Method area），反之可以使用编译执行来提升效率。当通过编译器优化时，发现并没有起到优化作用，可以通过逆优化退回到解释状态继续执行。</p><h3 id="如何判Hot"><a href="#如何判Hot" class="headerlink" title="如何判Hot"></a>如何判Hot</h3><ul><li>基于采样<br>栈顶定期采样，出现频繁的为hot。基本上该方式就是在定期看执行的方法，看到谁多谁就热。</li><li>基于统计<br>每个方法加个计数器，调了就加，多了就热。（这里计数器不单指对方法单元，还对方法内的回边操作另设计数器）</li></ul><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>JVM的JIT有两个Compiler:</p><ul><li>Client Compiler (C1)</li><li>Server Compiler (C2)</li></ul><p>而和GC策略很像的是，JVM同样为了折中做了分层策略：</p><ul><li>第 0 层：程序解释执行，解释器不开启性能监控功能，可触发第 1 层编译。</li><li>第 1 层：也称为 C1 编译，将字节码编译为本地代码，进行简单，可靠的优化，如有必要将加入性能监控的逻辑。</li><li>第 2 层（或 2 层以上）：也称为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li></ul><p>实施分层编译后，Client Compiler 和 Server Compiler 将会同时工作，许多代码都可能会被多次编译看，用 Client Compiler 获取更高的编译速度，用 Server Compiler 获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。</p><h2 id="AOT-Ahead-on-Time"><a href="#AOT-Ahead-on-Time" class="headerlink" title="AOT(Ahead on Time)"></a>AOT(Ahead on Time)</h2><p>编译器出来的东西比解释器快是开发者的共同认知。将优化交给编译器，并通过编译时的优化策略来提升性能，而JIT可以理解为是一个杂交的编译器与解释器，以方法为单位进行编译优化。而AOT需要的是将运行时的编译动作提前到编译时，在JAVA9以后提供该特性，但是服务端的大部分框架支持并不是很好，更多用到的还是android。</p><p>优点非常明显：</p><ul><li>不用运行时的性能监控及JIT编译器一直吃我们的CPU</li><li>方法区也不用浪费内存放机器码</li></ul><p>缺点就是全编译，并且失去平台无关性。</p><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p><img src="classloader.png" alt="classloarder"></p><p>三个ClassLoader分别负责加载对应的类，而加载一个类时，使用双亲委派策略，类装载器有载入类的需求时，会先请示其Parent使用其搜索路径帮忙载入，如果Parent 找不到,那么才由自己依照自己的搜索路径搜索类。<br>而最顶级的加载器BootstrapClassloader是C++实现的，仅逻辑存在，在Java中无类型定义。<br>而类加载器是同步的（线程安全），同一个类只会被加载一次。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用docker启动一个rabbitmq集群</title>
      <link href="2020/05/16/%E7%94%A8docker%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AArabbitmq%E9%9B%86%E7%BE%A4/"/>
      <url>2020/05/16/%E7%94%A8docker%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AArabbitmq%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="集群概念"><a href="#集群概念" class="headerlink" title="集群概念"></a>集群概念</h2><p>RabbitMQ有三种集群方式： 单机集群、普通集群和镜像集群。单机集群就跟玩似的，基本没有生产意义。</p><h3 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h3><p>这里包括几个概念：交换器、队列元数据、队列内容</p><ul><li>Exchange 的元数据信息在所有节点上是一致的，而 Queue（存放消息的队列）的完整数据则只会存在于创建它的那个节点上。</li><li>RabbitMQ 集群会始终同步四种类型的内部元数据（类似索引）：<ul><li>队列元数据：队列名称和它的属性；</li><li>交换器元数据：交换器名称、类型和属性；</li><li>绑定元数据：一张简单的表格展示了如何将消息路由到队列；</li><li>vhost元数据：为 vhost 内的队列、交换器和绑定提供命名空间和安全属性；<br>因此，当用户访问其中任何一个 RabbitMQ 节点时，通过 rabbitmqctl 查询到的元数据信息都是相同的。</li></ul></li><li>无法实现高可用性，当创建 queue 的节点故障后，其他节点是无法取到消息实体的。</li></ul><h3 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h3><p>把队列做成镜像队列，让各队列存在于多个节点中，属于 RabbitMQ 的高可用性方案。镜像模式和普通模式的不同在于，queue和 message 会在集群各节点之间同步，而不是在 consumer 获取数据时临时拉取。</p><h2 id="普通集群部署"><a href="#普通集群部署" class="headerlink" title="普通集群部署"></a>普通集群部署</h2><ol><li><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure></li><li><p>运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --hostname rabbit_host1 \</span><br><span class="line">    --name rabbitmq1 -p 15672:15672 -p 5672:5672 \</span><br><span class="line">    -e RABBITMQ_ERLANG_COOKIE=<span class="string">'rabbitmq_cookie'</span> \</span><br><span class="line">    rabbitmq:management</span><br><span class="line">docker run -d --hostname rabbit_host2 \</span><br><span class="line">    --name rabbitmq2 -p 5673:5672 \</span><br><span class="line">    --link rabbitmq1:rabbit_host1 \</span><br><span class="line">    -e RABBITMQ_ERLANG_COOKIE=<span class="string">'rabbitmq_cookie'</span> \</span><br><span class="line">    rabbitmq:management</span><br><span class="line">docker run -d --hostname rabbit_host3 \</span><br><span class="line">    --name rabbitmq3 -p 5674:5672 \</span><br><span class="line">    --link rabbitmq1:rabbit_host1 \</span><br><span class="line">    --link rabbitmq2:rabbit_host2 \</span><br><span class="line">    -e RABBITMQ_ERLANG_COOKIE=<span class="string">'rabbitmq_cookie'</span> \</span><br><span class="line">    rabbitmq:management</span><br></pre></td></tr></table></figure></li></ol><p>参数解释：</p><ul><li>-p 15672:15672 management 界面管理访问端口，这里只开放了rabbitmq1</li><li>-p 5672:5672 amqp 访问端口</li><li>–link 容器之间连接</li><li>–hostname 当前容器的host</li><li>Erlang Cookie 必须相同，Erlang节点通过交换 Erlang Cookie 获得认证。</li></ul><ol start="2"><li><p>加入节点到集群</p><ul><li><p>节点2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it rabbitmq2 bash</span><br><span class="line">&gt; rabbitmqctl stop_app</span><br><span class="line">&gt; rabbitmqctl reset</span><br><span class="line">&gt; rabbitmqctl join_cluster --ram rabbit@rabbit_host1</span><br><span class="line">&gt; rabbitmqctl start_app</span><br><span class="line">&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li><li><p>节点3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it rabbitmq3 bash</span><br><span class="line">&gt; rabbitmqctl stop_app</span><br><span class="line">&gt; rabbitmqctl reset</span><br><span class="line">&gt; rabbitmqctl join_cluster --ram rabbit@rabbit_host1</span><br><span class="line">&gt; rabbitmqctl start_app</span><br><span class="line">&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li></ul><p>–ram 表示设置为内存节点，忽略该参数默认为磁盘节点。该配置启动了3个节点，1个磁盘节点和2个内存节点。</p></li><li><p>访问管理端<br>可以通过guest/guest访问刚才在节点1上暴露的管理端口的页面：<a href="http://ip:15672" target="_blank" rel="noopener">http://ip:15672</a><br><img src="mq_management.png" alt="mq_management"></p></li></ol><h2 id="镜像集群部署"><a href="#镜像集群部署" class="headerlink" title="镜像集群部署"></a>镜像集群部署</h2><ol><li><p>策略policy概念  </p><p>使用RabbitMQ镜像功能，需要基于RabbitMQ策略来实现，策略policy是用来控制和修改群集范围的某个vhost队列行为和Exchange行为。策略policy就是要设置哪些Exchange或者queue的数据需要复制、同步，以及如何复制同步。  </p><p>为了使队列成为镜像队列，需要创建一个策略来匹配队列，设置策略有两个键“ha-mode和 ha-params（可选）”。ha-params根据ha-mode设置不同的值，下表说明这些key的选项。<br><img src="ha-policy.png" alt="ha-policy"></p></li><li><p>添加策略</p><ul><li>登录rabbitmq管理页面 ——&gt; Admin ——&gt; Policies ——&gt; Add / update a policy<br><img src="add-policy.png" alt="add-policy"></li><li>或者通过指令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all <span class="string">"^"</span> <span class="string">'&#123;"ha-mode":"all"&#125;'</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从线程到线程池到锁</title>
      <link href="2020/05/16/%E4%BB%8E%E7%BA%BF%E7%A8%8B%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>2020/05/16/%E4%BB%8E%E7%BA%BF%E7%A8%8B%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>要解释线程，就必须明白什么是进程，那什么是进程呢？如果学过操作系统的同学应该知道：<br>进程是指运行中的应用程序，每个进程都有自己<strong>独立的地址空间(内存空间)</strong>，比如用户点击桌面的IE浏览器，就启动了一个进程，操作系统就会为该进程分配独立的地址空间。当用户再次点击左面的IE浏览器，又启动了一个进程，操作系统将为新的进程分配新的独立的地址空间。目前操作系统都支持多进程。</p><blockquote><p>用户每启动一个进程，操作系统就会为该进程分配一个独立的内存空间。请注意是独立的内存空间。  </p></blockquote><p>在明白进程后，就比较容易理解线程的概念。<br>线程是进程中的一个实体，是被<strong>系统独立调度和分派的基本单位</strong>，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。线程有就绪、阻塞和运行三种基本状态。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>这里主要讲的是Java中的线程：</p><ul><li>线程是轻量级进程</li><li>没有独立的地址空间</li><li>一个进程可以有多个线程</li></ul><p>而Java中的线程有五个状态：</p><ol><li>新建状态(new)</li><li>就绪状态(Runnable)</li><li>运行状态(Running)</li><li>阻塞状态(Blocked)</li><li>死亡状态(Dead)</li></ol><h2 id="创建一个Java多线程"><a href="#创建一个Java多线程" class="headerlink" title="创建一个Java多线程"></a>创建一个Java多线程</h2><p>创建Java多线程有三种方式：</p><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>简单写个代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">50</span>;j++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用Thread类的currentThread()方法获取当前线程</span></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">10</span>) &#123;</span><br><span class="line"><span class="comment">//创建并启动第一个线程</span></span><br><span class="line"><span class="keyword">new</span> ExtendThread().start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并启动第二个线程</span></span><br><span class="line"><span class="keyword">new</span> ExtendThread().start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line"><span class="comment">//当通过继承Thread类的方式实现多线程时，可以直接使用this获取当前执行的线程</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" "</span>  + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意哦，启动要用start，run只是个普通的方法。</p><h3 id="实现Runnable接口进行创建"><a href="#实现Runnable接口进行创建" class="headerlink" title="实现Runnable接口进行创建"></a>实现Runnable接口进行创建</h3><p>代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImpRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(;i &lt; <span class="number">50</span>;i++) &#123;</span><br><span class="line"><span class="comment">//当线程类实现Runnable接口时，要获取当前线程对象只有通过Thread.currentThread()获取</span></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">30</span>;j++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + j);</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">10</span>) &#123;</span><br><span class="line">ImpRunnable thread_target = <span class="keyword">new</span> ImpRunnable();</span><br><span class="line"><span class="comment">//通过new Thread(target,name)的方式创建线程</span></span><br><span class="line"><span class="keyword">new</span> Thread(thread_target,<span class="string">"线程1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(thread_target,<span class="string">"线程2"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于本身已经有继承关系的类来说这种方式更加合适。</p><h3 id="通过实现Callable和Future接口进行创建"><a href="#通过实现Callable和Future接口进行创建" class="headerlink" title="通过实现Callable和Future接口进行创建"></a>通过实现Callable和Future接口进行创建</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdThreadImp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里call()方法的重写是采用lambda表达式，没有新建一个Callable接口的实现类</span></span><br><span class="line">FutureTask&lt;Integer&gt; task =  <span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)()-&gt;&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i &lt; <span class="number">50</span>;i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + </span><br><span class="line"><span class="string">"  的线程执行体内的循环变量i的值为："</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//call()方法的返回值</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">50</span>;j++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + </span><br><span class="line"><span class="string">" 大循环的循环变量j的值为："</span> + j);</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">20</span>) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(task,<span class="string">"有返回值的线程"</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"子线程的返回值："</span> + task.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，可以通过future对象获取一个线程的返回结果。</p><h2 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h2><p>我们为什么要用线程池呢？</p><ul><li>降低资源的消耗。线程本身是一种资源，创建和销毁线程会有CPU开销；创建的线程也会占用一定的内存。</li><li>提高任务执行的响应速度。任务执行时，可以不必等到线程创建完之后再执行。</li><li>提高线程的可管理性。线程不能无限制地创建，需要进行统一的分配、调优和监控。<ul><li>每一个独立的线程都会吃掉1M内存</li></ul></li></ul><h3 id="说说线程池的原理"><a href="#说说线程池的原理" class="headerlink" title="说说线程池的原理"></a>说说线程池的原理</h3><p>线程池的核心ThreadPoolExecutor的处理流程如下：<br><img src="ThreadPoolExecutor.jpg" alt="ThreadPoolExecutor"></p><ol><li>判断核心线程池是否已满，如果不是，则创建线程执行任务</li><li>如果核心线程池满了，判断队列是否满了，如果队列没满，将任务放在队列中</li><li>如果队列满了，则判断线程池是否已满，如果没满，创建线程执行任务</li><li>如果线程池也满了，则按照拒绝策略对任务进行处理</li></ol><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>我们来细看下ThreadPoolExecutor的构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span>;</span><br></pre></td></tr></table></figure><p>一共有7个参数，我们来逐个分析一下：</p><ol><li>corePoolSize： 线程池中的核心线程数<ol start="2"><li>maximumPoolSize： 线程池中的最大线程数</li><li>keepAliveTime： 空闲时间，当线程池数量超过核心线程数时，多余的空闲线程存活的时间，即：这些线程多久被销毁</li><li>unit： 空闲时间的单位，可以是毫秒、秒、分钟、小时和天，等等</li><li>workQueue： 等待队列，线程池中的线程数超过核心线程数时，任务将放在等待队列，它是一个BlockingQueue类型的对象</li><li>threadFactory： 线程工厂，我们可以使用它来创建一个线程</li><li>handler： 拒绝策略，当线程池和等待队列都满了之后，需要通过该对象的回调函数进行回调处理</li></ol></li></ol><h3 id="自带的几种线程池"><a href="#自带的几种线程池" class="headerlink" title="自带的几种线程池"></a>自带的几种线程池</h3><p>我们来看看Executors这个线程池工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建单一线程的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建固定数量的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"><span class="comment">// 创建带缓存的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 创建定时调度的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br><span class="line"><span class="comment">// 创建流式（fork-join）线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="单一线程的线程池"><a href="#单一线程的线程池" class="headerlink" title="单一线程的线程池"></a>单一线程的线程池</h4><p>这个线程池只有一个线程。若多个任务被提交到此线程池，那么会被缓存到队列（队列是无界队列）。当线程空闲的时候，按照FIFO的方式进行处理。</p><ul><li>它是一种固定大小的线程池；</li><li>corePoolSize和maximunPoolSize都为1；</li><li>keepAliveTime为0，意味着一旦有多余的空闲线程，就会被立即停止掉，但是由于队列无界，所以这里keepAliveTime无效。</li><li>阻塞队列采用了LinkedBlockingQueue，它是一个无界队列；</li><li>由于阻塞队列是一个无界队列，因此永远不可能拒绝任务；</li><li>由于采用了无界队列，实际线程数量将永远维持在nThreads，因此maximumPoolSize和keepAliveTime将无效。</li></ul><h4 id="固定数量的线程池"><a href="#固定数量的线程池" class="headerlink" title="固定数量的线程池"></a>固定数量的线程池</h4><p>和创建<strong>单一线程的线程池</strong>类似（只是把corePoolSize和maximunPoolSize都设置为n了而已），只是这儿可以并行处理任务的线程数更多一些罢了。</p><h4 id="带缓存的线程池"><a href="#带缓存的线程池" class="headerlink" title="带缓存的线程池"></a>带缓存的线程池</h4><p>这种方式创建的线程池，核心线程池的长度为0，线程池最大长度为Integer.MAX_VALUE（无界线程池）。由于本身使用SynchronousQueue作为等待队列的缘故，导致往队列里面每插入一个元素，必须等待另一个线程从这个队列删除一个元素。适合大量低耗时的操作。</p><ul><li>它是一个可以无限扩大的线程池；</li><li>它比较适合处理执行时间比较小的任务；</li><li>corePoolSize为0，maximumPoolSize为无限大，意味着线程数量可以无限大；</li><li>keepAliveTime为60S，意味着线程空闲时间超过60S就会被杀死；</li><li>采用SynchronousQueue装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。</li></ul><h4 id="定时调度的线程池"><a href="#定时调度的线程池" class="headerlink" title="定时调度的线程池"></a>定时调度的线程池</h4><p>和上面3个工厂方法返回的线程池类型有所不同，它返回的是ScheduledThreadPoolExecutor类型的线程池。平时我们实现定时调度功能的时候，可能更多的是使用第三方类库，比如：quartz等。但是对于更底层的功能，我们仍然需要了解。</p><p>我们写一个例子来看看如何使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定时调度，每个调度任务会至少等待`period`的时间，</span></span><br><span class="line">        <span class="comment">// 如果任务执行的时间超过`period`，则等待的时间为任务执行的时间</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                System.out.println(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定时调度，第二个任务执行的时间 = 第一个任务执行时间 + `delay`</span></span><br><span class="line">        executor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定时调度，延迟`delay`后执行，且只执行一次</span></span><br><span class="line">        executor.schedule(() -&gt; System.out.println(<span class="string">"5 秒之后执行 schedule"</span>), <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>等待队列是BlockingQueue类型的，理论上只要是它的子类，我们都可以用来作为等待队列。</p><p>自带的阻塞队列有4种：</p><ol><li>ArrayBlockingQueue，队列是有界的，基于数组实现的阻塞队列</li><li>LinkedBlockingQueue，队列可以有界，也可以无界。基于链表实现的阻塞队列</li><li>SynchronousQueue，不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作将一直处于阻塞状态。</li><li>PriorityBlockingQueue，带优先级的无界阻塞队列</li></ol><h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><p>ThreadFactory是一个接口，只有一个方法。既然是线程工厂，那么我们就可以用它生产一个线程对象。来看看这个接口的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new &#123;<span class="doctag">@code</span> Thread&#125;.  Implementations may also initialize</span></span><br><span class="line"><span class="comment">     * priority, name, daemon status, &#123;<span class="doctag">@code</span> ThreadGroup&#125;, etc.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r a runnable to be executed by new thread instance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> constructed thread, or &#123;<span class="doctag">@code</span> null&#125; if the request to</span></span><br><span class="line"><span class="comment">     *         create a thread is rejected</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看Executors的DefaultThreadFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现名称pool-{poolNum}-thread-{threadNum}。</p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>自带的4种策略：</p><ol><li>CallerRunsPolicy： 在调用者线程执行</li><li>AbortPolicy：直接抛出RejectedExecutionException异常</li><li>DiscardPolicy：任务直接丢弃，不做任何处理</li><li>DiscardOldestPolicy：丢弃队列里最旧的那个任务，再尝试执行当前任务</li></ol><p>这四种策略各有优劣，比较常用的是DiscardPolicy，但是这种策略有一个弊端就是任务执行的轨迹不会被记录下来。所以，我们往往需要实现自定义的拒绝策略， 通过实现RejectedExecutionHandler接口的方式。</p><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>提交任务有两个方法，execute()和submit(),区别在于execute提交不需要返回结果的任务，而submit提交返回结果任务（返回future）。</p><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>在线程池使用完成之后，我们需要对线程池中的资源进行释放操作，这就涉及到关闭功能。我们可以调用线程池对象的shutdown()和shutdownNow()方法来关闭线程池。</p><ul><li>shutdown()会将线程池状态置为SHUTDOWN，不再接受新的任务，同时会等待线程池中已有的任务执行完成再结束。</li><li>shutdownNow()会将线程池状态置为SHUTDOWN，对所有线程执行interrupt()操作，清空队列，并将队列中的任务返回回来。</li></ul><h3 id="正确的配置线程池参数"><a href="#正确的配置线程池参数" class="headerlink" title="正确的配置线程池参数"></a>正确的配置线程池参数</h3><p> 说是参数，主要还是指线程池的大小了，建议按照CPU的核数来进行配置，如果是I/O密集可以考虑两倍于CPU数的大小。<br> 另外的，可以通过Runtime.getRuntime().availableProcessors()来获取CPU的个数。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>说到锁就不得不提synchronized和Lock，先来一道面试题：</p><h3 id="synchronized和Lock有什么区别？"><a href="#synchronized和Lock有什么区别？" class="headerlink" title="synchronized和Lock有什么区别？"></a>synchronized和Lock有什么区别？</h3><ul><li>synchronized是关键字，Lock是接口<ul><li>synchronized在代码块结束后释放锁，而Lock需要手动释放</li><li>Lock可以设置超时，不用一直等待</li><li>Lock的锁状态可以判断</li><li>synchronized 非公平，不可中断，而Lock可公平也可以不公平</li><li>synchronized 悲观，而Lock是CAS乐观锁</li></ul></li></ul><p>我们不深入讲Lock了，毕竟是后妈生的，我们深入讲讲synchronized。</p><h3 id="synchronized锁的底层实现"><a href="#synchronized锁的底层实现" class="headerlink" title="synchronized锁的底层实现"></a>synchronized锁的底层实现</h3><p>我们知道，对象创建后都在我们的堆里，并且对象的内存布局可以分为三个部分：对象头、实例数据、对齐填充，而synchronized就是实现在对象头。</p><p>而synchronized又根据锁等级的不同在对象头中有不同的标记方式，我们称作Mark Word:<br><img src="markWord.png" alt="markWord"></p><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>对象共有4种状态的锁标志：</p><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>被逃逸分析优化掉，认为这块代码安全，之后怎们样都是这个状态，或者说所有线程的对像已经出了安全区。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</p><p>当一个线程访问同步代码块并获取锁时，会在 Mark Word 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</p><p>关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁。<br>轻量级锁是通过线程自旋来实现的，线程不会阻塞，从而提高性能，而对于自旋成功比较频繁的线程，会提高最高自旋的次数，这叫适应自旋锁。</p><p>而当一个线程自旋到限制次数时，就会升级为重量级锁。<br>或者当第三个线程来竞争资源时，同样也会升级为重量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>为什么重？ 因为重量级锁依赖的是对象监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，每次调用都是一次systeam call，需要从用户态切换到内核态，成本非常高。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 常见面试题</title>
      <link href="2020/05/16/Spring-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/05/16/Spring-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍下Spring"><a href="#介绍下Spring" class="headerlink" title="介绍下Spring"></a>介绍下Spring</h2><p>它是一个一站式（full-stack全栈式）框架，提供了从表现层-springMVC到业务层-spring再到持久层-springdata的一套完整的解决方案。我们在项目中可以只使用spring一个框架，它就可以提供表现层的mvc框架，持久层的Dao框架。它的两大核心IoC和AOP更是为我们程序解耦和代码简洁易维护提供了支持。</p><h2 id="Spring中AOP的应用场景、Aop原理、好处"><a href="#Spring中AOP的应用场景、Aop原理、好处" class="headerlink" title="Spring中AOP的应用场景、Aop原理、好处"></a>Spring中AOP的应用场景、Aop原理、好处</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>  Authentication 权限、Caching 缓存、Context passing 内容传递、Error handling 错误处理Lazy loading懒加载、Debugging调试、logging, tracing, profiling and monitoring 记录跟踪优化　校准、Performance optimization　性能优化、Persistence 持久化、Resource pooling　资源池、Synchronization　同步、Transactions 事务</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>  AOP是面向切面编程是代理模式的实现，是通过动态代理的方式为程序添加统一功能，集中解决一些公共问题。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>各个步骤之间的良好隔离性耦合性大大降低 </li><li>源代码无关性，再扩展功能的同时不对源码进行修改操作。</li></ul><h2 id="细说Spring-AOP原理"><a href="#细说Spring-AOP原理" class="headerlink" title="细说Spring AOP原理"></a>细说Spring AOP原理</h2><ul><li>每个 Bean 都会被 JDK 或者 Cglib 代理。取决于是否有接口。</li><li>每个 Bean 会有多个“方法拦截器”。注意：拦截器分为两层，外层由 Spring 内核控制流程，内层拦截器是用户设置，也就是 AOP。</li><li>当代理方法被调用时，先经过外层拦截器，外层拦截器根据方法的各种信息判断该方法应该执行哪些“内层拦截器”。内层拦截器的设计就是职责链的设计。</li></ul><h2 id="Spring的IOC"><a href="#Spring的IOC" class="headerlink" title="Spring的IOC"></a>Spring的IOC</h2><p>对于 IoC 来说，最重要的就是容器。容器管理着 Bean 的生命周期，控制着 Bean 的依赖注入。</p><p>Spring设计了两个接口用以表示容器。</p><ul><li>BeanFactory</li><li>ApplicationContext</li></ul><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>粗暴简单，可以理解为就是个 HashMap，Key 是 BeanName，Value 是 Bean 实例。通常只提供注册（put），获取（get）这两个功能。我们可以称之为 “低级容器”。</p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>ApplicationContext 可以称之为 “高级容器”。因为他比 BeanFactory 多了更多的功能。他继承了多个接口。因此具备了更多的功能。例如资源的获取，支持多种消息（例如 JSP tag 的支持），对 BeanFactory 多了工具级别的支持等待。所以你看他的名字，已经不是 BeanFactory 之类的工厂了，而是 “应用上下文”， 代表着整个大容器的所有功能。该接口定义了一个 refresh 方法，此方法是所有阅读 Spring 源码的人的最熟悉的方法，用于刷新整个容器，即重新加载/刷新所有的 bean。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP拥塞控制与滑动窗口</title>
      <link href="2020/05/16/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>2020/05/16/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>  拥塞控制就是防止过多的数据注入网络中，我们常见的方法有：</p><ul><li>慢开始与拥塞避免</li><li>快重传和快恢复</li><li>随机早期检测RED</li></ul><blockquote><p>拥塞窗口cwnd（congestion window）: 拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。</p></blockquote><blockquote><p>RTT(Round-Trip Time)：往返时延。是指数据从网络一端传到另一端所需的时间。</p></blockquote><h3 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h3><p>在慢开始的阶段，首先会以很小的cwnd发出报文，而每收到一次确认ACK回执后，将cwnd+1：<br><img src="%E6%85%A2%E5%BC%80%E5%A7%8B.jpg" alt="慢开始"><br>明显的，我们可以看到在网路空闲的情况下，cwnd会指数的向上增长，而持续的慢开始会导致窗口过大引起阻塞，我们还需要设置一个慢开始门限ssthresh状态变量：</p><ul><li>当cwnd&lt;ssthresh时，使用慢开始算法。</li><li>当cwnd&gt;ssthresh时，改用拥塞避免算法。</li><li>当cwnd=ssthresh时，慢开始与拥塞避免算法任意。</li></ul><p>而拥塞避免算法是每在一个RTT时间内将cwnd+1，将cwnd的增长曲线减缓。</p><p>当判断网络出现拥塞（没有收到确认）时，无论是慢开始还是拥塞避免的过程中，我们都会将ssthresh/2,并将cwnd归1重新开始慢加速。<br><img src="%E6%8B%A5%E5%A1%9E%E9%98%BB%E5%A1%9E.jpg" alt="拥塞阻塞"></p><h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br><img src="%E5%BF%AB%E9%87%8D%E4%BC%A0.jpg" alt="快重传"></p><p>而重传完后还会执行快恢复的算法：</p><ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去执行拥塞阻塞。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。如下图：<br><img src="%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D.jpg" alt="快重传和快恢复"></li></ul><h3 id="随机早期检测RED"><a href="#随机早期检测RED" class="headerlink" title="随机早期检测RED"></a>随机早期检测RED</h3><p>以上的拥塞避免算法并没有和网络层联系起来，实际上网络层的策略对拥塞避免算法影响最大的就是路由器的丢弃策略。在简单的情况下路由器通常按照先进先出的策略处理到来的分组。当路由器的缓存装不下分组的时候就丢弃到来的分组，这叫做尾部丢弃策略。这样就会导致分组丢失，发送方认为网络产生拥塞。更为严重的是网络中存在很多的TCP连接，这些连接中的报文段通常是复用路由路径。<strong>若发生路由器的尾部丢弃，可能影响到很多条TCP连接，结果就是这许多的TCP连接在同一时间进入慢开始状态。这在术语中称为全局同步。全局同步会使得网络的通信量突然下降很多，而在网络恢复正常之后，其通信量又突然增大很多。</strong></p><p>为避免发生网路中的全局同步现象，路由器采用随机早期检测(RED:randomearly detection)。该算法要点如下：</p><ul><li>使路由器的队列维持两个参数，即队列长队最小门限min和最大门限max，每当一个分组到达的时候，RED就计算平均队列长度。</li><li>平均队列长度小于最小门限——把新到达的分组放入队列排队。</li><li>平均队列长度在最小门限与最大门限之间——则按照某一概率将分组丢弃。</li><li>平均队列长度大于最大门限——丢弃新到达的分组。<br><img src="%E9%9A%8F%E6%9C%BA%E6%97%A9%E6%9C%9F%E6%A3%80%E6%B5%8BRED.jpg" alt="随机早期检测RED"></li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的可以接受缓冲区大小（这个字段越大说明网络吞吐量越高），从而控制发送方的发送速度，不过如果接收端的缓冲区一旦面临数据溢出，窗口大小值也会随之被设置一个更小的值通知给发送端，从而控制数据发送量（发送端会根据接收端指示，进行流量控制）。</p><p>这里再说明下ACK报文：</p><ul><li>期望接收到的下一字节的序号n</li><li>当前的窗口大小m</li></ul><p>而滑动窗口协议如图：<br><img src="%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt="滑动窗口"></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊分布式事务</title>
      <link href="2020/05/06/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/05/06/%E8%81%8A%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><blockquote><p>提到事务，我们的脑海里总是充满了与ACID的快乐回忆</p></blockquote><p>ACID指：</p><ul><li>原子性（Atomicity）<br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）<br>事务前后数据的完整性必须保持一致。</li><li>隔离性（Isolation）<br>事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li><li>持久性（Durability）<br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</li></ul><p>在传统单点架构中往往一个普通的DBMS就实现的功能，用就完事了，而在分布式系统中，由于各个服务节点的通信以及服务节点下线等等问题，我们引出了CAP定理。</p><ul><li>一致性(Consistency): 指在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li><li>可用性(Availability): 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li>分区容忍性(Partition tolerance): 即当节点之间无法正常通信时，就产生了分区，而分区产生后，依然能够保证服务可用，那么我们就说系统是分区容忍的。显然如果节点越多，且备份越 ，分区容忍度就越高（因为即便是其中一个或多个节点挂了，仍然有其它节点和备份可用）。</li></ul><p>而真正痛苦的，是我们只能满足其中的二者，为什么呢？</p><p>首先，我们拥有A和B这么两个服务</p><p>其中都存放了某个值val，当业务提交到A节点更新了val，而A向B发送更新报文阻塞时</p><p>来了个读取val的请求到B，那么我们此时有两重处理方案：</p><ol><li>先不理会A传来的更新，返回当前val给业务请求</li><li>阻塞住，等待A传来的更新执行完成后给新的val给业务请求</li></ol><p>可以发现，方案一放弃了部分一致性(无论如何会保证最终一致性)，保证了业务可用，我们称这类系统叫AP系统；而方案二舍弃了部分可用性(暂时的阻塞)，保证了数据的一致，我们称这类系统叫CP系统。</p><p>而真的的生产中，我们不太可能（特殊需求的模块，如支付可能要求CP）有完全的AP或者CP，就有了BASE理论：</p><ul><li>Basically Available(基本可用) 牺牲部分可用性（延迟、部分功能），保证系统的<code>基本可用</code></li><li>Soft State（软状态） 允许事务存在中间状态</li><li>Eventually Consistent（最终一致性） 允许短时间的不一致，但最终保持数据一致</li></ul><p>以上是简单说明下理论，我们接着来看看具体实现的算法。</p><h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><p><code>很具要参考性的算法，参考了2pc的代表选手有：XA、Raft、Paxos、TCC</code>  </p><p>2PC指二段提交，顾名思义：  </p><ol><li>提交事务请求  （preCommit）<ul><li>事务询问 协调者询问事务是否可以执行</li><li>执行事务 参与者执行事务（不提交）</li><li>事务反馈 反馈事务执行结果</li></ul></li><li>执行事务提交 （doCommit）<ul><li>同意提交 协调者确认所有反馈事务成功，通知参与者可以提交</li><li>事务提交 接受请求，提交已执行的事务</li><li>提交反馈 反馈提交结果</li><li>执行完成  </li></ul></li></ol><p>当其中某个节点反馈失败时，协调者控制事务中断与回滚</p><ul><li>发送回滚请求 协调者向所有参与者发起回滚请求</li><li>事务回滚 参与者回滚事务</li><li>回滚反馈 参与者向协调者反馈回滚结果</li><li>执行完成  </li></ul><p>看上去复杂度并不高，但是问题同样很明显：</p><ol><li>阻塞 所有参与事务的逻辑均处于阻塞状态。</li><li>单点 协调者存在单点问题，如果协调者出现故障，参与者将一直处于锁定状态。</li><li>脑裂 如果只有部分参与者接收并执行了Commit请求，会导致节点数据不一致。</li></ol><h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><p><code>出名选手不多，不过有很多开源实现，可以自己找嘛</code></p><p>可以看出，2PC的大部分问题都是来自与节点的不稳定，无论是协调者还是参与者都缺少容错机制。而3PC在preCommit前添加了一个canCommit的操作，步骤如下：</p><ol><li>提交询问 （canCommit）<ul><li>资源询问 协调者询问事务是否准备就绪</li><li>事务反馈 反馈事务执行结果，在这一步协调者和参与者都有超时机制保护</li></ul></li><li>提交事务请求  （preCommit）<ul><li>事务询问 协调者询问事务是否可以执行</li><li>执行事务 参与者执行事务（不提交）</li><li>事务反馈 反馈事务执行结果，在这一步协调者和参与者都有超时机制保护</li></ul></li><li>执行事务提交 （doCommit）<ul><li>同意提交 协调者确认所有反馈事务成功，通知参与者可以提交</li><li>事务提交 接受请求，提交已执行的事务</li><li>提交反馈 反馈提交结果，在这一步协调者和参与者都有超时机制保护</li><li>执行完成  </li></ul></li></ol><p>可以看到3PC在三次过程中均有超时机制，其策略大概如下：</p><ol><li>canCommit阶段，事务管理器等待参与者响应超时，超时则中断事务；</li><li>preCommit阶段，事务管理器等待参与者影响超时，超时则回滚事务；</li><li>doCommit阶段，参与者等待事务管理器的commit或者rollback指令，超时则默认自动commit；</li></ol><p>但是我们发现，脑裂问题依旧存在，这并不是一个很好的方案，因为数据最终一致性都没法解决。</p><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><p>TCC指的是Try-Confirm-Cancel，其实现在业务层面，在拥有一定的代码侵入的容忍度的前提下可以较好的通过业务代码解决2PC的一致性问题。<br>其三个阶段如下：</p><ol><li>预留阶段 （Try）<ul><li>协调者尝试让各个节点保留资源，准备执行各自的任务</li><li>协调者注册确认与取消操作</li><li>协调者收集各节点，针对预留节点的回复</li></ul></li><li>确认阶段  （Confirm）<ul><li>执行预留阶段资源满足情况下，协调者确认操作，协调者向各个节点发送事务确认执行的操作</li><li>各节点向协调者返回各自任务执行情况</li></ul></li><li>取消阶段 （Cancel）<ul><li>执行预留阶段，如果某节点不满足资源，协调者通知其他节点全部取消操作，达到一致性  </li></ul></li></ol><p>TCC的本质是补偿事务，也是基于二阶段提交思想，程序应用扮演了协调者的角色，很明显的，TCC需要实现Confirm与Cancel的幂等，完成业务层面上的补偿。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从B-tree与B+tree到MySQL</title>
      <link href="2019/11/28/%E4%BB%8EB-tree%E4%B8%8EB-tree%E5%88%B0Mysql/"/>
      <url>2019/11/28/%E4%BB%8EB-tree%E4%B8%8EB-tree%E5%88%B0Mysql/</url>
      
        <content type="html"><![CDATA[<h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h2><p>我们可以将一个b树简单的理解成一个自平衡的m叉树，并将它称作m阶b树；同样的，如果你看了<a href="https://noir-lattice.github.io/2019/11/06/%E8%81%8A%E8%81%8A%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8C%E8%B7%B3%E8%A1%A8/">聊聊红黑树和跳表</a>，也可以将一个二三树理解为是一个3阶B树。  </p><p>对于一个m阶的红黑树来说：</p><ul><li>B树中所有节点的孩子节点数中的最大值称为B树的阶，记为m</li><li>树中的每个节点最多有m个子树</li><li>根节点如果不是终端节点，至少有两棵子树</li><li>除根节点外所有非叶节点都拥有m/2棵子树（m/2向上取整）</li><li>所有叶子都在同一层</li></ul><p>形象的我们用一个4阶的b树与平衡二叉树来表示同一组数据：<br><img src="b-tree&AVL.png" alt="bTree&amp;AVL"></p><p>从结构上来看，我们可以看到，b树较之于二叉树更加的扁平，而这意味着跨节点操作更加的少，当数据结构以节点粒度对数据进行落盘后，使用二叉树结构的查询对于磁盘的io次数有显著的优化（当数据节点读入后认为已拉入内存，后续读取磁盘io压力小）。</p><p>什么意思呢？ 当我们将这棵树以节点为单位存储到磁盘中，读取最远端的叶子数据需要的磁盘操作如下：<br><img src="b-tree&AVL-1.png" alt="bTree&amp;AVL"><br>明显的，二叉树的读盘操作更加的频繁，在这样的场景下二叉树的性能必然是劣于b树的，这也是为什么数据库的索引结构更加多的采用b树及其变种而不使用二叉树的原因。</p><h2 id="B-tree-1"><a href="#B-tree-1" class="headerlink" title="B+tree"></a>B+tree</h2><p>而b+tree与b-tree有什么不同呢？看图说话：<br><img src="b-tree&b+tree.png" alt="b-tree&amp;b+tree.png"><br>明显的，所有的叶子节点可以组成一个完整的数据索引链表，我们可以便利的获取一段区间值的内容出来，这样的好处不仅仅是批量区间读取使得高效。根据局部性原理，通过这样的方式加载到内存中的数据有很大可能被后续的访问命中，从而减少后续的I/O操作。</p><h2 id="对于MySQL"><a href="#对于MySQL" class="headerlink" title="对于MySQL"></a>对于MySQL</h2><p>对于索引而言，B+并不是万能妙药。简单的思考就会发现问题:</p><ul><li>对于B+树如何定阶，而定阶后树的深度如何把握？</li><li>对于频繁的操作，维护树的稳定而做的分裂与合并同样造成大量的I/O影响性能。</li></ul><h3 id="定阶"><a href="#定阶" class="headerlink" title="定阶"></a>定阶</h3><p>对于操作系统来说，将数据分页（又成block）可以加速磁盘读写，一般而言，我们每个节点占用的大小应小于等于一个页。通常的，linux下一个block大小约为4KB，那么可以推断出：</p><ul><li>一个4B（Int）大小的索引，加上4B大小的子树节点指针，阶数关系有<br><code>m * (4 + 4) = 4 KB</code><br>易得阶数<code>m=512</code>，而此时对于亿级别的数据，最大深度约为<br><code>log(512/2)(10^8) = 3.32 ~= 4</code><br>只有当数据激增至百亿时，深度才会至5。</li><li>一个32*8B(Varchar(32))大小的索引，加上4B大小的子树节点指针，阶数关系有<br><code>m * (32 * 8 + 4) = 4 KB</code><br>得阶数<code>m~=16</code>，而此时对于亿级别的数据，最大深度约为<br><code>log(16/2)(10^8) ~= 9 ~= 9</code></li></ul><p>以上，我们可以认为主键或索引不宜过长，或过长的索引数据级应该要小，不然主键过大导致树深度激增过快将大幅度的拉低性能。</p><h3 id="维护稳定性"><a href="#维护稳定性" class="headerlink" title="维护稳定性"></a>维护稳定性</h3><p>对于一个标准的B+树，在插入叶子节点而叶子节点无法容纳时，会触发平衡策略进行该叶子节点的分裂，而对于MySQL而言，为了减少I/O，策略上会选择新开一个独立叶子来存储新入的数据而不是对旧有数据进行分裂。<br>这就造成了索引不可以过分离散的问题，当索引值不连续，将开出非常多的独立叶子，而每个block内数据少的可怜，从而隐式的使B+树阶数退化进而深度激增影响性能。<br>这也是为什么使用这种策略的数据引擎(innodb)会推荐使用连续的自增id。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> B-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊红黑树和跳表</title>
      <link href="2019/11/06/%E8%81%8A%E8%81%8A%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8C%E8%B7%B3%E8%A1%A8/"/>
      <url>2019/11/06/%E8%81%8A%E8%81%8A%E7%BA%A2%E9%BB%91%E6%A0%91%E5%92%8C%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在咱们聊红黑树之前，我们不妨先思考一个问题，在一组数中如何最快查找存在某个数呢？  </p><ul><li>笔者第一反应是构造hash表一个你乐意插多少插多少，O(1)大法好。   </li></ul><p>那么如果需要构造有序列表后再查呢？</p><ul><li>那么咱们用二分法，O(logN)还是不错的</li></ul><p>从上我们就可以引申出二叉树来实现二分查找了，对于一个完全二叉树来说，查找一个数是O(logN)，插入或删除同样是O(logN)，但是现实会这么美好么？</p><h2 id="二叉树的退化"><a href="#二叉树的退化" class="headerlink" title="二叉树的退化"></a>二叉树的退化</h2><p>对于一个构造好的二叉树，我们不断的插入一组组顺序的数据，很容易就会使树变的不平衡，极端的会退化一个O(N)的链表。<br><img src="tree.png" alt="tree"><br>如何让我们构造的查找树平衡呢？二三树的办法是：</p><ul><li>用不同类型的节点来标记，比如三节点就有退化的味道</li><li>坏味道堆积会使三节点向根移动</li><li>根会因三节点而移动从而达到平衡</li></ul><h2 id="二三树"><a href="#二三树" class="headerlink" title="二三树"></a>二三树</h2><p>二三树有两种节点，二节点就像普通二叉树一样，存放一个数据，其左分支下皆小该值，其右分支皆大于该值，三节点内存放两个数据，其左分支下皆小于该节点内数值，其右分支下皆大于该节点内右数值，其中间分支下值位于左数值与右数值间。<br><br>我们从构造一个二三树来了解他是怎么维持平衡的：<br><img src="2-3_1.png" alt="2-3_1"><br>上图描绘了一个四个数值的二三树的构造过程，虚线框内表示稳定结构树（即插入完成的树状态）。<br>我们继续向二三树中插入顺序的值：<br><img src="2-3_2.png" alt="2-3_2"><br>可以发现，在将三节点不断的拆分和向根部递推后构造形成的树总是稳定的，我们可以认为二三树构造的二分查找树是颗平衡树，即在动态的构造过程中，我们依旧可以维持稳定的O(logN)的查询效率。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>当你理解了二三树就理解了红黑树，将二三树图中的红色数据理解为红节点，并将其右侧的值用指针链接就构造了一颗红黑树。</p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>这是一个类似二分查找的算法，我们可以简单的理解为是链表+多级索引。  </p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>咱们先从构造一个链表开始<br><img src="linklist.png" alt="linklist"><br>显而易见，查询插入和删除都是O(n)  </p><p>那咱们再为这个链表添加一级索引呢？<br><img src="level-1.png" alt="level-1"><br>比如咱们要找其中的某个数n（非索引节点），一个一个跳着找是趋向于n/2次找到，虽然复杂度还是O(n)，但是不是比刚才好点了呢？</p><p>那咱们再为这个链表加一级索引<br><img src="level-2.png" alt="level-2"><br>同样我们去查某个数n（非索引节点），二级索引命中区间使用了n/4次，一级索引找到该数使用了1次</p><p>一鼓作气，再加一级!<br><img src="level-3.png" alt="level-3"><br>去查某个数n（非索引节点），三级索引命中区间使用了n/8次</p><p>同样的，我们不断的向上加索引，加至顶层索引只有两个节点<br><img src="leveln.png" alt="levelln"><br>这时我们去查找某个点时，是不是发现我们好像用索引构造了一个二分树？<br>对了，现在查询已经O(logN)了。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对于红黑树而言，插入是个无比痛苦的事情，大概步骤如下：</p><ol><li>找到插入位置</li><li>判断插入后是否影响平衡，影响平衡后分裂</li><li>分裂后向上插入，回到2  </li></ol><p>而跳表使用随机级数策略，只要保证随机的级数符合全索引内出现的概率即可，什么意思呢？<br><em>我有一个18个点跳表，跳数2（索引间有一个节点），最高级数4, 此时插入一个数</em>  </p><p>首先我们要计算各级数索引在全部索引中的概率： </p><ul><li>4级: 2/(2^4 + 2^3 + 2^2 + 2) = 1/15</li><li>3级: 2^2/(2^4 + 2^3 + 2^2 + 2) = 2/15</li><li>2级: 2^3/(2^4 + 2^3 + 2^2 + 2) = 4/15</li><li>1级: 2^4/(2^4 + 2^3 + 2^2 + 2) = 8/15</li></ul><p>插入一个节点的步骤：</p><ul><li>找到插入位置</li><li>按上述概率随机生成级数，修改查询路径记录的索引并插入</li></ul><p>学过概率论的同学应该知道，这样生成的跳表分布基本上是均匀的，那么咱们就可以认为这样生成的跳表查询复杂度就是O(logN)。</p><h2 id="为什么用跳表"><a href="#为什么用跳表" class="headerlink" title="为什么用跳表"></a>为什么用跳表</h2><p><em>红黑树真好，但是跳表真香。</em>  </p><p>为什么跳表香？</p><ul><li>好实现</li><li>索引便利，可以快速找到区间中批量数据，更方便做批操作。  </li></ul><p>至于为啥说好实现、好做批量操作，自己手写个跳表直观感受一下就好了呀。</p><h2 id="为什么不用跳表"><a href="#为什么不用跳表" class="headerlink" title="为什么不用跳表"></a>为什么不用跳表</h2><ul><li>如果数量级少，索引级数小的情况下，随机构建插入节点存在偶发的低效。</li><li>高度扩容后顺序大量插入数据会导致扩容前数据索引不会被高级索引cover</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2-3树（红黑树） </tag>
            
            <tag> 跳表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab CI/CD与线上k8s环境集成</title>
      <link href="2019/11/04/gilab-CI-CD%E4%B8%8E%E7%BA%BF%E4%B8%8Ak8s%E7%8E%AF%E5%A2%83%E9%9B%86%E6%88%90/"/>
      <url>2019/11/04/gilab-CI-CD%E4%B8%8E%E7%BA%BF%E4%B8%8Ak8s%E7%8E%AF%E5%A2%83%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>  依赖k8s做集成测试和持续的版本交付，并与gitlab runner集成，实现提交merge request即提测，上master后自动release。本文将从以下几步简述实现过程：</p><ul><li>私有docker registry搭建并与docker runner集成</li><li>kubernetes与pipeline</li><li>helm发布和istio做滚动发布的流控</li></ul><h2 id="搭建docker-registry并与docker-runner-集成"><a href="#搭建docker-registry并与docker-runner-集成" class="headerlink" title="搭建docker-registry并与docker runner 集成"></a>搭建docker-registry并与docker runner 集成</h2><p>  首先，docker-registry作为我们容器镜像的仓库，对于生产环境来说自然是架设在同一子网来说比较合适，不然在发布版本后的新容器创建时会出奇的慢并且会占用网络，而对于我们日常的集成测试，则需要在我们的开发平台同一子网下架设。拓扑如下：<br>  <img src="struct.png" alt="struct"></p><h3 id="配置kubernetes的runner环境变量"><a href="#配置kubernetes的runner环境变量" class="headerlink" title="配置kubernetes的runner环境变量"></a>配置kubernetes的runner环境变量</h3><p>  配置k8s的runner环境变量有两种方式：</p><ul><li>页面添加配置<br>在项目operations-&gt;kubenetes下添加配置</li><li>在环境变量中添加kubeconfig文件<br>在ci中将文件移动到.kube/config（若gitlab版本过低可以将环境配置echo至该文件）  </li></ul><p>配置好环境变量后，打包一个带有kubectl的镜像推到开发registry后，使用pipeline时既可以通过该基础镜像进行k8s的操作了。</p><h3 id="安装helm-tiller"><a href="#安装helm-tiller" class="headerlink" title="安装helm/tiller"></a>安装helm/tiller</h3><p>单纯的使用kubectl肯定不满足我们编排的需求，可以安装helm/tiller并打包helm开发镜像使用helm对应用进行发布。  </p><ol><li><p>下载安装helm在本地</p></li><li><p>配置好.kube/config</p></li><li><p>rbac配置（未开启可跳过该步骤）</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># vim tiller-clusterrolebinding.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: tiller</span><br><span class="line">    namespace: kube-system</span><br><span class="line">  </span><br><span class="line">#kubectl apply -f tiller-clusterrolebinding.yaml</span><br></pre></td></tr></table></figure></li><li><p>安装tiller</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm init --service-account tiller --upgrade --tiller-image=registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.14.1</span><br></pre></td></tr></table></figure></li><li><p>打包helm镜像至开发registry备后续helm部署使用</p></li></ol><h2 id="kubernetes与pipeline"><a href="#kubernetes与pipeline" class="headerlink" title="kubernetes与pipeline"></a>kubernetes与pipeline</h2><p>  在与kubernetes集成前，我们以一个敏捷开发涉及到涉及到打包、测试、staging发布、滚动发布的pipeline来举例说明。<br>  .gitlab-ci.yaml中定义：<br>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">publish</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">staging</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">rollin</span></span><br></pre></td></tr></table></figure></p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>  可以通过指定的基础镜像提供的环境将源码程序打包，如通过gradle镜像将springboot项目打包成可运行jar包：<br>  <img src="buildJob.png" alt="buildJob">  </p><p>  gitlab-ci.yaml中定义：<br>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build_jar:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">registry.local/gradle:latest</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">-e</span> <span class="string">"\nspring.profiles.active=prod"</span> <span class="string">&gt;&gt;</span> <span class="string">src/main/resources/application.properties</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gradle</span> <span class="string">-g</span> <span class="string">./.cache</span> <span class="string">bootJar</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">paths:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./.cache</span></span><br><span class="line">    <span class="comment"># keep cache across branch</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">gradle</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span> <span class="string">[build/libs/t1-api-cert.jar]</span></span><br><span class="line">  <span class="attr">retry:</span></span><br><span class="line">    <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>  这里主要指集成测试，在拥有docker环境时，我们可以创建相应的服务容器（如mysql、redis等）提供集成测试：<br>  <img src="testJob.png" alt="testJob"></p><p>  gitlab-ci.yaml中定义：<br>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">unit_test:</span></span><br><span class="line"><span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">registry.local/gradle:latest</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">gradle</span> <span class="string">-g</span> <span class="string">./.cache</span> <span class="string">test</span> <span class="string">--info</span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">MYSQL_DATABASE:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">Ok36369ok</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">registry.local/mysql</span></span><br><span class="line">  <span class="attr">alias:</span> <span class="string">mysql</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">redis:latest</span></span><br><span class="line"><span class="attr">retry:</span></span><br><span class="line">  <span class="number">2</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">paths:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">./.cache</span></span><br><span class="line">  <span class="comment"># keep cache across branch</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">gradle</span></span><br></pre></td></tr></table></figure></p><h3 id="staging发布"><a href="#staging发布" class="headerlink" title="staging发布"></a>staging发布</h3><p>  stage环境为了更好的测试真实的网络环境，建议部署在生产下（可以创建一个新的namespace来放这些容器），而真实环境根据不同的应用架构将有不同的拓扑与部署方案，这里仅举例一个简单的单块应用的helm部署：<br>  <img src="staging.png" alt="staging"><br>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">publish_image:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">publish</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">registry.local/dind:latest</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t="repository.prod/app:v1.0.1"</span> <span class="string">.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">docker</span> <span class="string">push</span> <span class="string">repository.prod/app:v1.0.1</span></span><br><span class="line">  <span class="attr">retry:</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line"><span class="attr">deploy_stage:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">staging</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">registry.local/helm:latest</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">helm</span> <span class="string">upgrade</span> <span class="string">--tiller-namespace</span> <span class="string">kube-system</span> <span class="string">deploy-$CI_PROJECT_NAME</span> <span class="string">chart/</span> <span class="string">--install</span> <span class="string">\</span></span><br><span class="line">      <span class="string">--wait</span> <span class="string">\</span></span><br><span class="line">      <span class="string">--set</span> <span class="string">hosts[0]="$PRODUCT_HOST"</span> <span class="string">\</span></span><br><span class="line">      <span class="string">--set</span> <span class="string">appLabel="$CI_PROJECT_NAME"</span> <span class="string">\</span></span><br><span class="line">      <span class="string">--set</span> <span class="string">containerPort=$CONTAINER_PORT</span> <span class="string">\</span></span><br><span class="line">      <span class="string">--set</span> <span class="string">replicaCount=$replicas</span> <span class="string">\</span></span><br><span class="line">      <span class="string">--set</span> <span class="string">image.repository=repository.prod/app:v1.0.1</span> <span class="string">\</span></span><br><span class="line">      <span class="string">--namespace="$KUBE_NAMESPACE"</span> <span class="string">\</span></span><br><span class="line">      <span class="string">--version="$CI_PIPELINE_ID-$CI_COMMIT_SHA"</span>  </span><br><span class="line">  <span class="attr">retry:</span></span><br><span class="line">    <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>  其中的各个参数是自定义chart中规定的，可以根据具体项目及团队习惯进行定制修改并添加功能，比如滚动发布就只需要集成对应的istio的yaml配置并暴露出对应的VALUES配置来进行流量控制。</p><h3 id="滚动发布"><a href="#滚动发布" class="headerlink" title="滚动发布"></a>滚动发布</h3><p>  在生产部署中，我们可能会采用各种策略来实现版本发布，如金丝雀、灰度（滚动）发布等，咱们可以在helm charts中定义好实现方式，如使用istio的router-rule实现。</p><h2 id="关于-gitlab-ci-yaml"><a href="#关于-gitlab-ci-yaml" class="headerlink" title="关于.gitlab-ci.yaml"></a>关于.gitlab-ci.yaml</h2><ul><li><p>支持模板继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.product: &amp;prod_template</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br><span class="line">  retry:</span><br><span class="line">    2</span><br><span class="line"></span><br><span class="line">.rollin: &amp;rollin_template</span><br><span class="line">  &lt;&lt;: *prod_template</span><br><span class="line">  stage: rollin</span><br><span class="line">  script:</span><br><span class="line">  - init_kube_config</span><br><span class="line">  - check_kube_domain</span><br><span class="line">  - ensure_namespace</span><br><span class="line">  - create_secret</span><br><span class="line">  - check_chart</span><br><span class="line">  - deploy canary $ROLLIN_PERCENTAGE</span><br><span class="line">  environment:</span><br><span class="line">    name: $CI_PROJECT_NAME</span><br><span class="line">    url: http://$CI_PROJECT_NAME.test.com</span><br><span class="line"></span><br><span class="line">deploy_canary:</span><br><span class="line">  &lt;&lt;: *rollin_template</span><br><span class="line">  stage: canary</span><br><span class="line">  variables:</span><br><span class="line">    ROLLIN_PERCENTAGE: $CANARY_WEITHG</span><br></pre></td></tr></table></figure></li><li><p>支持include</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"><span class="attr">include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">template:</span> <span class="string">jobs/build.gitlab-ci.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">template:</span> <span class="string">jobs/test.gitlab-ci.yml</span></span><br></pre></td></tr></table></figure></li><li><p>支持函数定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">  stage: test</span><br><span class="line">  image: registry.local/alpine:latest</span><br><span class="line">  script:</span><br><span class="line">    - hello</span><br><span class="line">.auto_devops: &amp;auto_devops |</span><br><span class="line">  export CI_WORD=&quot;hello gitlab ci!</span><br><span class="line">  function hello() &#123;</span><br><span class="line">    echo $CI_WORD</span><br><span class="line">  &#125;</span><br><span class="line">before_script:</span><br><span class="line">  - *auto_devops</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> CI/CD </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的一些理解</title>
      <link href="2019/10/26/Redis%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
      <url>2019/10/26/Redis%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>redis是一个开源的内存中的数据结构存储系统，我们常常可以那他来用作缓存、数据库和消息中间件。高效而可靠的外部缓存服务是应用的不可缺少的一部分。<br>本文将从以下几个角度来谈谈咱们的理解：</p><ul><li>有多快</li><li>为什么快</li><li>有什么用</li><li>怎么用好</li></ul><h2 id="有多快"><a href="#有多快" class="headerlink" title="有多快"></a>有多快</h2><p>  咱们可以看看官方的<a href="https://redis.io/topics/benchmarks" target="_blank" rel="noopener">说明</a>。  </p><h2 id="为什么快"><a href="#为什么快" class="headerlink" title="为什么快"></a>为什么快</h2><ul><li>和数据库不同，redis将数据放在内存里，读写数据不会受到磁盘I/O限制。</li><li>数据结构简单，对于数据操作也简单。</li><li>采用单线程单进程，避免了不必要的上下文切换及concurrent问题，同样的不会因进程切换而导致性能损耗</li><li>NIO(多路复用)</li></ul><h3 id="内存数据"><a href="#内存数据" class="headerlink" title="内存数据"></a>内存数据</h3><p>  <strong>Redis is an in-memory but persistent on disk database, so it represents a different trade off where very high write and read speed is achieved with the limitation of data sets that can’t be larger than memory. Another advantage of in memory databases is that the memory representation of complex data structures is much simpler to manipulate compared to the same data structure on disk, so Redis can do a lot, with little internal complexity. At the same time the two on-disk storage formats (RDB and AOF) don’t need to be suitable for random access, so they are compact and always generated in an append-only fashion (Even the AOF log rotation is an append-only operation, since the new version is generated from the copy of data in memory).</strong></p><p>Redis的数据是在内存中并可以持久化到硬盘的，这是一个折中的方案，意味着存储不大于内存限制的数量级时将可以拥有非常高的读写速率。另外的一个优点是，对于存储一个复杂的数据结构而言，内存表示将会简单很多，所以Redis能降低实现的复杂度。同时，RDB和AOF产生的持久化因为并不需要随机访问，他们产生的文件总是非常小且是增量产生（在AOF滚动日志中也只是添加动作，新的副本版本只是从当前内存中产生的）。</p><p>我们可以理解为：</p><ul><li>存储数据量由内存决定（不建议使用虚拟内存，该功能已在2.4版本后停止支持）</li><li>内存中实现的数据结构比存储于文件的复杂度更低，衍生可以理解为用字段表示数据结构与程序使用数据结构的比较。</li><li>RDB与AOF为redis持久化的两种方式</li><li>我们从Redis拿数据访问的是内存</li></ul><p>那么持久化至硬盘的数据既然不访问，那我们就可以猜测是类似于日志备份的一个策略，在启动时通过这些文件，将数据拉起到内存中。</p><p>我们继续看RDB和AOF：</p><ul><li>RDB(Redis DataBase): 指在指定的时间间隔内将内存中的数据集快照写入磁盘，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li><li>AOF(Append Only File): 以日志的形式记录操作，可以打开文件看到详细的操作记录。</li></ul><p>不出所料，RDB是全备份，AOF是日志备份，差异显而易见。  </p><p>优势：</p><ul><li>RDB全备份更好拉起，不影响性能且适合做冷备份。</li><li>AOF有更高的数据安全性且其备份高可读，可以通过其做误删回复<br>劣势：</li><li>RDB在数据量大时可能导致服务停止小段时间（1秒左右），在持久化间隔期宕机将失去改段时间的数据</li><li>AOF的日志文件更大且数据恢复更慢，每次操作的日志操作将导致QPS降低</li></ul><p>而为了鱼和熊掌兼得，在Redis4.0开始提供了RDB-AOF 混合持久化： 这种持久化能够通过 AOF 重写操作创建出一个同时包含 RDB 数据和 AOF 数据的 AOF 文件， 其中 RDB 数据位于 AOF 文件的开头， 它们储存了服务器开始执行重写操作时的数据库状态： 至于那些在重写操作执行之后执行的 Redis 命令， 则会继续以 AOF 格式追加到 AOF 文件的末尾， 也即是 RDB 数据之后。</p><h3 id="单进程单线程"><a href="#单进程单线程" class="headerlink" title="单进程单线程"></a>单进程单线程</h3><p>这里说的单进程单线程并不是指Redis就一个线程，而是处理请求是单一线程，毕竟咱们RDB还需要fork出进程去备份。</p><p>而对于处理请求单一线程，由于我们的内存操作够快，所以哪怕将并行化的请求串行化处理也能保证很高的QPS，而串行化处理事件避免了各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。当然，对于一个核数多的吓人的机器，咱们可以多开一些实例来提高利用率嘛。</p><h3 id="非阻塞I-O模型"><a href="#非阻塞I-O模型" class="headerlink" title="非阻塞I/O模型"></a>非阻塞I/O模型</h3><p>NIO有很多种，Redis使用I/O多路复用。咱们这里不铺开叙述，多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符（FileDescription，简称FD），如果有一个文件描述符（FileDescription）就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。虾米意思？就是派一个代表，同时监听多个文件描述符是否有数据到来。等着等着，如有有数据，就告诉某某你的数据来啦！赶紧来处理吧。  </p><p>而Redis 会优先选择时间复杂度为 O(1) 的 I/O 多路复用函数作为底层实现，包括 Solaries 10 中的 evport、Linux 中的 epoll 和 macOS/FreeBSD 中的 kqueue，上述的这些函数都使用了内核内部的结构，并且能够服务几十万的文件描述符。如果找不到，那就只能用select（仅能服务1024个文件描述符）了。</p><h2 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用"></a>有什么用</h2><p>  丰富的数据结构支持：</p><ul><li>String：缓存、限流、计数器、分布式锁、分布式Session</li><li>Hash：存储用户信息、用户主页访问量、组合查询</li><li>List：微博关注人时间轴列表、简单队列</li><li>Set：赞、踩、标签、好友关系</li><li>Zset：排行榜</li></ul><h3 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h3><p>  <img src="redisObj.png" alt="redisObj"></p><ul><li>dictEntry：Redis给每个key-value键值对分配一个dictEntry，里面有着</li><li>key和val的指针，next指向下一个dictEntry形成链表，这个指针可以将多个</li><li>哈希值相同的键值对链接在一起，由此来解决哈希冲突问题(链地址法)。</li><li>sds：键key“hello”是以SDS（简单动态字符串）存储。</li><li>redisObject：值val“world”存储在redisObject中。实际上，redis常用5中类型都是以redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。</li></ul><h3 id="redis通讯协议-RESP"><a href="#redis通讯协议-RESP" class="headerlink" title="redis通讯协议(RESP)"></a>redis通讯协议(RESP)</h3><p>RESP 是redis客户端和服务端之前使用的一种通讯协议；</p><p>RESP 的特点：实现简单、快速解析、可读性好</p><p>For Simple Strings the first byte of the reply is “+” 回复</p><p>For Errors the first byte of the reply is “-“ 错误</p><p>For Integers the first byte of the reply is “:” 整数</p><p>For Bulk Strings the first byte of the reply is “$” 字符串</p><p>For Arrays the first byte of the reply is “*” 数组</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串对象的底层实现可以是int、raw、embstr。embstr编码和int是通过调用一次内存分配函数来分配一块连续的空间，而raw需要调用两次。通常的embstr：&lt;=39字节的字符串。int：8个字节的长整型。raw：大于39个字节的字符串。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>一个quicklist(以前是Linklist和Ziplist)，可以两端进两端出<br>quickList 是 zipList 和 linkedList 的混合体。它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。因为链表的附加空间相对太高，prev 和 next 指针就要占去 16 个字节 (64bit 系统的指针是 8 个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。<br><img src="quicklist.png" alt="quicklist"></p><h3 id="Linklist"><a href="#Linklist" class="headerlink" title="Linklist"></a>Linklist</h3><p>双端列表，好插入，不好随机读取</p><h3 id="Ziplist"><a href="#Ziplist" class="headerlink" title="Ziplist"></a>Ziplist</h3><p>压缩列表<br><img src="zlist.png" alt="ziplist"></p><h3 id="Skiplist"><a href="#Skiplist" class="headerlink" title="Skiplist"></a>Skiplist</h3><p>为啥用跳表不用红黑树？</p><h2 id="怎么用好"><a href="#怎么用好" class="headerlink" title="怎么用好"></a>怎么用好</h2><ol><li>主从复制<br>一主多从或者一主一从。<br>主从之间数据完全相同，采用全量复制与增量复制的方式同步。</li><li>哨兵模式<br>官方推荐的HA方案就是Redis-Sentinel，在master挂掉后会选举一个master提供服务</li><li>Redis-Cluster<br>集群方式提供了分布式的数据存储，即实现了分片(sharding)的支持，为了分片数据的可用的多备份<br>redis cluster集群方式支持主从自动切换<br>redis cluster集群只有一个库，单例或者主从的话有多个库<br>redis cluster集群去中心化，只要通过其中一个端口连接即可<br>redis cluster集群，只有一个db库，不支持多库<br>堆起来做HA，堆起来拉高QPS!</li></ol>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从代码到线上,高度集成的gitlab工具链(三): Gitpage</title>
      <link href="2019/10/24/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BA%BF%E4%B8%8A-%E9%AB%98%E5%BA%A6%E9%9B%86%E6%88%90%E7%9A%84gitlab%E5%B7%A5%E5%85%B7%E9%93%BE-%E4%B8%89-Gitpage/"/>
      <url>2019/10/24/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BA%BF%E4%B8%8A-%E9%AB%98%E5%BA%A6%E9%9B%86%E6%88%90%E7%9A%84gitlab%E5%B7%A5%E5%85%B7%E9%93%BE-%E4%B8%89-Gitpage/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>  就像github一样，gitlab一样提供了托管静态站点的能力，结合GitLab CI的力量和GitLab Runner的帮助，你可以为你的单独项目、用户或组部署静态页面。</p><h2 id="开启Gitlab-page"><a href="#开启Gitlab-page" class="headerlink" title="开启Gitlab page"></a>开启Gitlab page</h2><p>  你需要一个域名解析或者让组员们自己改hosts，当然，多个静态站要添加很多条记录，而自己搭建个name服务器支持泛域名解析可能是更加科学的办法。</p><h2 id="泛域名配置"><a href="#泛域名配置" class="headerlink" title="泛域名配置"></a>泛域名配置</h2><ul><li><p>修改/etc/gitlab/gitlab.rb文件</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pages_external_url <span class="string">'http://example.io'</span></span><br></pre></td></tr></table></figure></li><li><p>拉起gitlab配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建一个page项目"><a href="#创建一个page项目" class="headerlink" title="创建一个page项目"></a>创建一个page项目</h2><p>  首先，要知道名称是跟着用户名或者组名走的，如下图<br>  <img src="projectname.png" alt="Commit"></p><p>  然后写咱们的.gitlab-ci.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># requiring the environment of NodeJS 10</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">node:10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add 'node_modules' to cache for speeding up builds</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules/</span> <span class="comment"># Node modules and dependencies</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">gitbook-cli</span> <span class="string">-g</span> <span class="comment"># install gitbook</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">gitbook</span> <span class="string">fetch</span> <span class="number">3.2</span><span class="number">.3</span> <span class="comment"># fetch final stable version</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">gitbook</span> <span class="string">install</span> <span class="comment"># add any requested plugins in book.json</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gitbook</span> <span class="string">build</span> <span class="string">.</span> <span class="string">public</span> <span class="comment"># build to public path</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">branches</span> <span class="comment"># this job will affect every branch except 'master'</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># the 'pages' job will deploy and build your site to the 'public' path</span></span><br><span class="line"><span class="attr">pages:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gitbook</span> <span class="string">build</span> <span class="string">.</span> <span class="string">public</span> <span class="comment"># build to public path</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">public</span></span><br><span class="line">    <span class="attr">expire_in:</span> <span class="number">1</span> <span class="string">week</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span> <span class="comment"># this job will affect only the 'master' branch</span></span><br></pre></td></tr></table></figure><p>添加目录文件SUMMARY.md</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Summary</span><br><span class="line"></span><br><span class="line">* [Introduction](README.md)</span><br></pre></td></tr></table></figure><p>添加内容文件README.md</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## hello gitpage</span><br></pre></td></tr></table></figure><p>这里使用gitbook来作为page范例，更多可参考<a href="https://gitlab.com/pages" target="_blank" rel="noopener">Gitlab page examples</a></p><h2 id="等待pipeline"><a href="#等待pipeline" class="headerlink" title="等待pipeline"></a>等待pipeline</h2><p>在提交以上内容后，gitlab会根据ci文件内定义的job开始pipeline（需要创建gitlab runner, 创建与注册runner在<a href="https://noir-lattice.github.io/2019/08/28/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BA%BF%E4%B8%8A-%E9%AB%98%E5%BA%A6%E9%9B%86%E6%88%90%E7%9A%84gitlab%E5%B7%A5%E5%85%B7%E9%93%BE-%E4%B8%80-%E5%B7%A5%E5%85%B7%E9%93%BE%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">从代码到线上,高度集成的gitlab工具链(一): CI/CD</a>），在等待job完成后咱们就可以在对应的web地址访问了。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从代码到线上,高度集成的gitlab工具链(一): CI/CD</title>
      <link href="2019/09/12/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BA%BF%E4%B8%8A-%E9%AB%98%E5%BA%A6%E9%9B%86%E6%88%90%E7%9A%84gitlab%E5%B7%A5%E5%85%B7%E9%93%BE-%E4%B8%80-%E5%B7%A5%E5%85%B7%E9%93%BE%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>2019/09/12/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BA%BF%E4%B8%8A-%E9%AB%98%E5%BA%A6%E9%9B%86%E6%88%90%E7%9A%84gitlab%E5%B7%A5%E5%85%B7%E9%93%BE-%E4%B8%80-%E5%B7%A5%E5%85%B7%E9%93%BE%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>作为可以私有部署的开源仓库管理系统，gitlab作为一个互联网公司的代码仓库当然是一件寻常的事情了，Gitlab除了git的基础功能，在线的代码审查及review,还有</p><ul><li>ci/cd工具链</li><li>gitflow</li><li>gitpage</li><li>wiki</li><li>项目管理工具支持  </li></ul><p>本篇将从各个工具链的搭建将其作用平述。</p>  <a id="more"></a><h2 id="Gitlab环境搭建"><a href="#Gitlab环境搭建" class="headerlink" title="Gitlab环境搭建"></a>Gitlab环境搭建</h2><p>gitlab是一个很大的项目，采用微服务架构的同时也支持单机部署，这里作为研发人员使用我们使用最方便运维与部署的容器部署作为实例。</p><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull gitlab/gitlab-ce</span><br></pre></td></tr></table></figure><h3 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /srv/gitlab/config</span><br><span class="line">mkdir -p /srv/gitlab/logs </span><br><span class="line">mkdir -p /srv/gitlab/data</span><br></pre></td></tr></table></figure><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always \</span><br><span class="line">  --name gitlab \</span><br><span class="line">  --hostname gitlab.example.com \</span><br><span class="line">  -p 80:80 -p 22:22 \</span><br><span class="line">  -v /srv/gitlab/config:/etc/gitlab \</span><br><span class="line">  -v /srv/gitlab/logs:/var/<span class="built_in">log</span>/gitlab \</span><br><span class="line">  -v /srv/gitlab/data:/var/opt/gitlab \</span><br><span class="line">  --privileged=<span class="literal">true</span> \</span><br><span class="line">  gitlab/gitlab-ce</span><br></pre></td></tr></table></figure><p>等待一段时间后docker ps即可看到STATUS为healthy即启动完成可以访问了。</p><h2 id="Gitlab-runner部署"><a href="#Gitlab-runner部署" class="headerlink" title="Gitlab runner部署"></a>Gitlab runner部署</h2><p>Gitlab runnner 可以运行指定作业（通过编写pipeline）与gitlab的ci模块协调作业进行CI/CD。</p><h3 id="安装gitlab-runner"><a href="#安装gitlab-runner" class="headerlink" title="安装gitlab runner"></a>安装gitlab runner</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">  -v /srv/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure><h3 id="注册gitlab-runner"><a href="#注册gitlab-runner" class="headerlink" title="注册gitlab runner"></a>注册gitlab runner</h3><p>在使用root用户登入gitlab后可以进入/admin/runners下获取token进行runner注册</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始注册</span></span><br><span class="line">docker run --rm -t -i -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register</span><br><span class="line"></span><br><span class="line"><span class="comment"># gitlab url</span></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line">https://gitlab.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入获取的token</span></span><br><span class="line">Please enter the gitlab-ci token <span class="keyword">for</span> this runner</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入该runner的描述</span></span><br><span class="line">Please enter the gitlab-ci description <span class="keyword">for</span> this runner</span><br><span class="line">[hostname] my-runner</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择改runner执行的标签（不选默认执行所有标签）</span></span><br><span class="line">Please enter the gitlab-ci tags <span class="keyword">for</span> this runner (comma separated):</span><br><span class="line">my-tag,another-tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择runner的执行程序</span></span><br><span class="line">Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:</span><br><span class="line">docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择容器的默认镜像</span></span><br><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">alpine:latest</span><br></pre></td></tr></table></figure><p>之后刷新/admin/runners页面发现新的runner就算注册成功了，如果需要多个runner只需重复执行以上步骤创建并注册多个runner container即可。</p><h3 id="开启DIND的高级权限"><a href="#开启DIND的高级权限" class="headerlink" title="开启DIND的高级权限"></a>开启DIND的高级权限</h3><p>DIND(docker in docker)在生产发布时十分有用，在未开启privileged时是无法再自定义任务中使用DIND来打包并发布镜像的。<br>修改runner container的配置文件/srv/gitlab-runner/config/config.toml，将privileged设置为true后重启该容器。</p><h2 id="编写并运行我们的第一个pipeline"><a href="#编写并运行我们的第一个pipeline" class="headerlink" title="编写并运行我们的第一个pipeline"></a>编写并运行我们的第一个pipeline</h2><p>我们在创建项目后，可以在项目根路径创建.gitlab-ci.yml文件来编写我们的CI/CD任务并在每次提交后自动运行pipeline。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">PRINT_WORD:</span> <span class="string">hello</span></span><br><span class="line"></span><br><span class="line"><span class="attr">say_hellow:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">$PRINT_WORD</span></span><br></pre></td></tr></table></figure><p>提交一次更改即可在项目的CI/CD–&gt;Pipelines中查验运行结果。<br>后续我们可以通过编写pipeline集成自动化的ut/it、可以集成helm或kubectl做生产部署、可以通过格式化的测试报表与gitlab页面集成，相比于jenkins的推拉webhook等方式更加与研发平台集成，更加切合Devops的谁开发、谁部署、谁运维。</p>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从代码到线上,高度集成的gitlab工具链(二): gitflow</title>
      <link href="2019/09/12/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BA%BF%E4%B8%8A-%E9%AB%98%E5%BA%A6%E9%9B%86%E6%88%90%E7%9A%84gitlab%E5%B7%A5%E5%85%B7%E9%93%BE-%E4%BA%8C-gitflow/"/>
      <url>2019/09/12/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E7%BA%BF%E4%B8%8A-%E9%AB%98%E5%BA%A6%E9%9B%86%E6%88%90%E7%9A%84gitlab%E5%B7%A5%E5%85%B7%E9%93%BE-%E4%BA%8C-gitflow/</url>
      
        <content type="html"><![CDATA[<h2 id="从git到gitflow到gitlab的gitflow"><a href="#从git到gitflow到gitlab的gitflow" class="headerlink" title="从git到gitflow到gitlab的gitflow"></a>从git到gitflow到gitlab的gitflow</h2><p>  git作为一个分布式的版本管理软件拥有优秀的分支模型支持，而基于模型与长期实践中获得的版本管理工作流程就叫gitflow，而gitlab则为日常开发工作提供了gitflow的系列可视化工具链。</p>  <a id="more"></a><h2 id="总结和实践一个分支模型"><a href="#总结和实践一个分支模型" class="headerlink" title="总结和实践一个分支模型"></a>总结和实践一个分支模型</h2><p>  对于不同大小的公司有不同的管理办法，形而上学的完美解决方案是不存在的，公司人员协调与事物规章甚至问题追责办法对于不同规模不同性质的机构实体都有不同的处理办法，对于软件项目的分支模型设计同样是这个道理。  </p><p>  一个简单的道理，如果是个人项目，不需要协调与管理、需求明确、任务时间自由且设计思路清晰，那么我肯定不会建出五花八门的分支用于消磨自己的时间；而对于项目与人员都很复杂，模块需要负责人员并提供好过程与质量管理，那么我们肯定需要根据实际情况创建不同的分支来进行管理来维护开发进程的稳定。 </p><p>  常见的，我们可能会创建的分支有：</p><ul><li>master: 主分支，仅做对外发布作用，只读（仅可通过release/hotfix合并）</li><li>develop: 开发分支，从develop签出，只读（仅可通过feature/release合并）</li><li>feature: 特性分支，临时分支，可以有多个，从develop签出，在release提测后可删除</li><li>release: 测试分支，临时分支，从某个feature分支中签出，提交测试功能完成后合并至develop/master完成发布后可删除</li><li>hotfix: 紧急修复分支，临时分支，从master签出，修复bug后合并至develop/master完成发布</li></ul><h3 id="Commit-graph"><a href="#Commit-graph" class="headerlink" title="Commit graph"></a>Commit graph</h3><p>  <img src="git-model@2x.png" alt="Commit graph"><br>  在该模型中，值得注意的是：</p><ul><li>master的每次merge都是合并的一次提交并打标（做发布的版本控制）</li><li>严格的只读保护master和develop（代码保护）</li><li>feature需要在release中提测过才可以合并发布（ci/cd及管理友好）</li></ul><p>以上我们举了较为通用的gitflow分支模型，在配合相应的人员管理与需求工具集成便可以方便而有序的维持项目开发过程。</p><h2 id="gitlab提供的工具"><a href="#gitlab提供的工具" class="headerlink" title="gitlab提供的工具"></a>gitlab提供的工具</h2><ul><li>提交视图<br><img src="commit.png" alt="Commit"></li><li>分支管理<br><img src="branche.png" alt="branche"></li><li>标记管理<br><img src="tags.png" alt="tags"></li><li>分支视图<br><img src="graph.png" alt="graph"></li></ul><h2 id="值得推荐的工具与参考"><a href="#值得推荐的工具与参考" class="headerlink" title="值得推荐的工具与参考"></a>值得推荐的工具与参考</h2><ul><li><a href="http://danielkummer.github.io/git-flow-cheatsheet/" target="_blank" rel="noopener">gitflow extensions</a></li><li><a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> devops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
            <tag> gitflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernates环境搭建(三): PV/PVC和StorageClass</title>
      <link href="2019/08/22/kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E4%B8%89-PV-PVC%E5%92%8CStorageClass/"/>
      <url>2019/08/22/kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E4%B8%89-PV-PVC%E5%92%8CStorageClass/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当你使用容器部署数据应用时，可能为了备份的便利或者数据安全将数据挂在在硬盘或者其他网络存储上，本文以NFS作为StorageClass部署并集成到kubernetes集群作为示例简述相关环境的搭建。 </p><a id="more"></a><h3 id="名称解释"><a href="#名称解释" class="headerlink" title="名称解释"></a>名称解释</h3><ul><li>PV(PersistentVolume): 一段网络存储，是归属于kubernetes管理的集群资源。</li><li>PVC(PersistentVolumeClaim): 用户的存储请求，PVC消耗PV资源并可以声明大小和读写权限</li><li>StorageClass: 为管理员提供了一种描述他们提供的存储的“类”的方法。 不同的类可能映射到服务质量级别，或备份策略，或者由群集管理员确定的任意策略。</li></ul><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><p>  Provisioning ——-&gt; Binding ——–&gt; Using ——&gt; Releasing ——&gt; Recycling</p><ul><li>Provisioning: 准备供应PV</li><li>Binding: 根据PVC绑定PV</li><li>Using: 正常挂载使用</li><li>Releasing: 解除绑定并保留数据准备根据Recycling策略进行回收或删除</li><li>Recycling: 回收，有三种策略：保留、删除和回收（不同的存储引擎或云提供商支持的策略不同）</li></ul><h2 id="搭建NFS服务器"><a href="#搭建NFS服务器" class="headerlink" title="搭建NFS服务器"></a>搭建NFS服务器</h2><p>使用硬盘读写高并且与kubernetes集群网络质量高的一天主机进行部署NFS服务器作为网络存储。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#master节点安装nfs</span></span><br><span class="line">yum -y install nfs-utils</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建nfs目录</span></span><br><span class="line">mkdir -p /nfs/data/</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改权限</span></span><br><span class="line">chmod -R 777 /nfs/data</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑export文件</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/nfs/data *(rw,no_root_squash,sync)</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置生效</span></span><br><span class="line">exportfs -r</span><br><span class="line"><span class="comment">#查看生效</span></span><br><span class="line">exportfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动rpcbind、nfs服务</span></span><br><span class="line">systemctl restart rpcbind &amp;&amp; systemctl <span class="built_in">enable</span> rpcbind</span><br><span class="line">systemctl restart nfs &amp;&amp; systemctl <span class="built_in">enable</span> nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看 RPC 服务的注册状况</span></span><br><span class="line">rpcinfo -p localhost</span><br></pre></td></tr></table></figure><h2 id="kubernetes集群安装nfs-client-provisioner"><a href="#kubernetes集群安装nfs-client-provisioner" class="headerlink" title="kubernetes集群安装nfs-client-provisioner"></a>kubernetes集群安装nfs-client-provisioner</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定nfs服务器ip和导出的路径</span></span><br><span class="line">helm install --name nfs-client --<span class="built_in">set</span> nfs.server=x.x.x.x --<span class="built_in">set</span> nfs.path=/exported/path stable/nfs-client-provisioner</span><br></pre></td></tr></table></figure><h2 id="查看配置存储类"><a href="#查看配置存储类" class="headerlink" title="查看配置存储类"></a>查看配置存储类</h2><p>安装好nfs-client-provisioner的charts后会自动创建对应的StorageClass，可以直接在rancher的管理台上查看和修改配置。  </p><p>  <img src="rancher.png" alt="管理存储类">  </p><p>修改默认存储类  </p><p>  <img src="change-default.png" alt="修改默认存储类"></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernates环境搭建(二): 安装Rancher并部署Kubernetes</title>
      <link href="2019/08/07/kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E4%BA%8C-%E5%AE%89%E8%A3%85Rancher%E5%B9%B6%E9%83%A8%E7%BD%B2Kubernetes/"/>
      <url>2019/08/07/kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E4%BA%8C-%E5%AE%89%E8%A3%85Rancher%E5%B9%B6%E9%83%A8%E7%BD%B2Kubernetes/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Rancher"><a href="#安装Rancher" class="headerlink" title="安装Rancher"></a>安装Rancher</h2><p>找个node节点外的机器安装Rancher（当然你可以在node上装然后换掉80和443接口），此处新开机器 rancher - 192.168.1.13</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher:stable</span><br></pre></td></tr></table></figure><p>等待容器启动后访问<a href="https://192.168.1.13" target="_blank" rel="noopener">https://192.168.1.13</a><br>按照提示设置密码、设置语言与确认访问路径（注意确认地址为node可以访问的地址）。</p><h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><ul><li>添加集群<br><img src="add-1.png" alt="添加集群"></li><li>选择部署类型与集群名称<br><img src="add-2.png" alt="选择部署类型与集群名称"></li><li>选择角色并部署节点<br><img src="add-3.png" alt="选择角色并部署节点"></li><li>等待集群Active</li></ul><h2 id="配置部署工具"><a href="#配置部署工具" class="headerlink" title="配置部署工具"></a>配置部署工具</h2><ul><li><p>获取配置<br><img src="config-1.png" alt="获取配置"></p></li><li><p>保存配置文件<br><img src="config-2.png" alt="保存配置文件"></p></li><li><p><a href="https://www.cnrancher.com/docs/rancher/v2.x/cn/install-prepare/download/kubernetes/" target="_blank" rel="noopener">下载kubectl</a></p></li><li><p><a href="https://www.cnrancher.com/docs/rancher/v2.x/cn/install-prepare/download/helm/" target="_blank" rel="noopener">下载helm</a></p></li><li><p>初始化tiller</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm version #获取TILLER_VERSION</span><br><span class="line">helm init --upgrade -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:$TILLER_VERSION --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts #替换$TILLER_VERSION</span><br></pre></td></tr></table></figure></li><li><p>设置tiller RBAC</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl --namespace kube-system create serviceaccount tiller</span><br><span class="line">kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller</span><br><span class="line">helm init --service-account tiller --upgrade</span><br></pre></td></tr></table></figure></li></ul><h2 id="部署kubernetes-dashboard"><a href="#部署kubernetes-dashboard" class="headerlink" title="部署kubernetes dashboard"></a>部署kubernetes dashboard</h2><ul><li><p>创建配置文件value.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ingress 配置与tls</span></span><br><span class="line"><span class="comment"># ingress:</span></span><br><span class="line"><span class="comment">#   tls:</span></span><br><span class="line"><span class="comment">#   - hosts:</span></span><br><span class="line"><span class="comment">#     - xxx</span></span><br><span class="line"><span class="comment">#     secretName: your-secret</span></span><br><span class="line"><span class="comment">#   enabled: true</span></span><br><span class="line"><span class="comment">#   hosts:</span></span><br><span class="line"><span class="comment">#   - xxx</span></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line"><span class="attr">repository:</span> <span class="string">docker.io/mirrorgooglecontainers/kubernetes-dashboard-amd64</span></span><br><span class="line"><span class="attr">tag:</span> <span class="string">v1.10.1</span></span><br><span class="line"><span class="attr">rbac:</span></span><br><span class="line">  <span class="attr">clusterAdminRole:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>部署应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade -f value.yaml dashboard stable/kubernetes-dashboard</span><br></pre></td></tr></table></figure></li><li><p>访问测试<br>使用保存的kubeconfig成功登入<br><img src="test.png" alt="成功登入"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> rancher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernates环境搭建(一): 系统环境配置与docker-ce</title>
      <link href="2019/08/07/kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E4%B8%80-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8Edocker-ce/"/>
      <url>2019/08/07/kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E4%B8%80-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8Edocker-ce/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>这是kubernates环境搭建的第一篇，我们要做的是尽可能的记录部署过程，为各位未来更好的理解与使用kubernetes做好基础准备。<br>需要的环境：</p><ul><li>Centos7 4c8m * 3 (系统非必须要求，其他linux发现版同理，此处使用三台并不是一定要三台，你自己all-in-one也行)</li><li>清醒的头脑</li><li>还算不错的网络<br>主机环境：</li><li>node01 - 192.168.1.10/24</li><li>node02 - 192.168.1.11/24</li><li>node03 - 192.168.1.12/24<a id="more"></a></li></ul><h2 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sudo sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config</span><br><span class="line">systemctl stop firewalld.service &amp;&amp; systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><h2 id="设置语言与时区"><a href="#设置语言与时区" class="headerlink" title="设置语言与时区"></a>设置语言与时区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">sudo echo 'LANG="en_US.UTF-8"' &gt;&gt; /etc/profile;source /etc/profile</span><br></pre></td></tr></table></figure><h2 id="依照主机名配置host"><a href="#依照主机名配置host" class="headerlink" title="依照主机名配置host"></a>依照主机名配置host</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@rancher ~]# cat /etc/hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.1.10 node01</span><br><span class="line">192.168.1.11 node02</span><br><span class="line">192.168.1.12 node03</span><br></pre></td></tr></table></figure><h2 id="配置三台主机的时间同步"><a href="#配置三台主机的时间同步" class="headerlink" title="配置三台主机的时间同步"></a>配置三台主机的时间同步</h2><p>使用云服务时一般已配置好时间同步，这里只是说明一下，如要详细配置：<br><img src="search.jpg" alt="你不会搜索么？"></p><h2 id="网络配置优化"><a href="#网络配置优化" class="headerlink" title="网络配置优化"></a>网络配置优化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/sysctl.conf&lt;&lt;EOF</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.ipv4.neigh.default.gc_thresh1=4096</span><br><span class="line">net.ipv4.neigh.default.gc_thresh2=6144</span><br><span class="line">net.ipv4.neigh.default.gc_thresh3=8192</span><br><span class="line">EOF</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><h2 id="添加系统模块"><a href="#添加系统模块" class="headerlink" title="添加系统模块"></a>添加系统模块</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@rancher ~] cat add_mod.sh</span><br><span class="line">\#!/bin/sh</span><br><span class="line">mods=(</span><br><span class="line">br_netfilter</span><br><span class="line">ip6_udp_tunnel</span><br><span class="line">ip_set</span><br><span class="line">ip_set_hash_ip</span><br><span class="line">ip_set_hash_net</span><br><span class="line">iptable_filter</span><br><span class="line">iptable_nat</span><br><span class="line">iptable_mangle</span><br><span class="line">iptable_raw</span><br><span class="line">nf_conntrack_netlink</span><br><span class="line">nf_conntrack</span><br><span class="line">nf_conntrack_ipv4</span><br><span class="line">nf_defrag_ipv4</span><br><span class="line">nf_nat</span><br><span class="line">nf_nat_ipv4</span><br><span class="line">nf_nat_masquerade_ipv4</span><br><span class="line">nfnetlink</span><br><span class="line">udp_tunnel</span><br><span class="line">VETH</span><br><span class="line">VXLAN</span><br><span class="line">x_tables</span><br><span class="line">xt_addrtype</span><br><span class="line">xt_conntrack</span><br><span class="line">xt_comment</span><br><span class="line">xt_mark</span><br><span class="line">xt_multiport</span><br><span class="line">xt_nat</span><br><span class="line">xt_recent</span><br><span class="line">xt_set</span><br><span class="line">xt_statistic</span><br><span class="line">xt_tcpudp</span><br><span class="line">)</span><br><span class="line">for mod in $&#123;mods[@]&#125;;do</span><br><span class="line">    modprobe $mod</span><br><span class="line">        lsmod |grep $mod</span><br><span class="line">done</span><br><span class="line">chmod a+x add_mod.sh</span><br><span class="line">./add_mod.sh</span><br></pre></td></tr></table></figure><h2 id="安装Docker-ce"><a href="#安装Docker-ce" class="headerlink" title="安装Docker-ce"></a>安装Docker-ce</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://releases.rancher.com/install-docker/17.06.sh | sh</span><br></pre></td></tr></table></figure><p>注意这里需要下载Rancher支持的版本（<a href="https://rancher.com/docs/rancher/v2.x/en/installation/requirements/）" target="_blank" rel="noopener">https://rancher.com/docs/rancher/v2.x/en/installation/requirements/）</a></p><h2 id="配置守护进程"><a href="#配置守护进程" class="headerlink" title="配置守护进程"></a>配置守护进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@node01 ~]# cat /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["https://xxxxx.xxx.com/"],</span><br><span class="line">  "insecure-registries": ["192.168.1.10","IP:PORT"]</span><br><span class="line">  "max-concurrent-downloads": 3,</span><br><span class="line">  "max-concurrent-uploads": 5,</span><br><span class="line">  "storage-driver": "overlay2",</span><br><span class="line">  "storage-opts": ["overlay2.override_kernel_check=true"],</span><br><span class="line">  "log-driver": "json-file",</span><br><span class="line">  "log-opts": &#123;</span><br><span class="line">    "max-size": "100m",</span><br><span class="line">    "max-file": "3"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置说明：</p><ul><li>registry-mirrors: 国内镜像加速地址</li><li>insecure-registries: 非TLS私有registry地址</li><li>max-concurrent-downloads: 同时docker pull的并发数量（不设置在过高的并发时会lock网络，出一个docker的bug;过低会lock后续pull）</li><li>max-concurrent-uploads: 同时docker push的并发数</li><li>storage-driver和storage-opts: 容器存储驱动（注意overlay2需要ext4,xfs需要开启d_type）</li><li>log-driver和log-opts配置日志，防止日志过多撑爆硬盘</li></ul><p>重启服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service restart docker</span><br></pre></td></tr></table></figure><h2 id="其他的方式"><a href="#其他的方式" class="headerlink" title="其他的方式"></a>其他的方式</h2><p>上面的操作每一台都要做，就算写成脚本也累死个人，所以建议安装RancherOS，自带docker-ce，你只要配制下守护进程重启下docker服务就好了。<br><img src="saywhat.jpg" alt="saywhat"></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> rancher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器世代下的DevOps</title>
      <link href="2019/08/06/%E5%90%83%E9%B2%B8%E4%B8%96%E4%BB%A3%E4%B8%8B%E7%9A%84DevOps/"/>
      <url>2019/08/06/%E5%90%83%E9%B2%B8%E4%B8%96%E4%BB%A3%E4%B8%8B%E7%9A%84DevOps/</url>
      
        <content type="html"><![CDATA[<h2 id="鲸🐋了"><a href="#鲸🐋了" class="headerlink" title="鲸🐋了"></a>鲸🐋了</h2><p>  9102年你说你不认识这鲸鱼我是一万个不信~<br>  <img src="docker.jpeg" alt="一群胖鲸鱼"><br>  容器给我们带来的不仅仅是干净且隔离的运行环境，更是轻量应用的最佳部署方案之一，在便捷的部署，快速的启停中，我们的开发与部署的模式已然发生变化。</p> <a id="more"></a><h2 id="于开发"><a href="#于开发" class="headerlink" title="于开发"></a>于开发</h2><p>如果我们简单谈外包项目或者需求明确的一次性交付的项目，自然用传统的瀑布模型管理软件过程即可，而对于抢占市场或者demo（甚至PPT）产品从预想-&gt;简单实现-&gt;产品落地这类周期的我们就需要谈Agile Development。<br> <img src="ad.png" alt="Agile Development"><br>选好了软件开发模型，再对具体项目架构进行选型，而架构选型自然离不开传统的单体应用架构和如今的微服务架构的一番辩谈了。既然叫传统，自然要总结出个十个八个的缺点对其进行攻击，继而引申出微服务架构的万般好与千般妙处，但是筒子们，我们要正确意识到问题的根源，切合实际的对架构及现有应用需求进行思考并理智选型。</p><h3 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h3><p> <img src="single.jpg" alt="单体应用">  </p><h3 id="微服务应用架构"><a href="#微服务应用架构" class="headerlink" title="微服务应用架构"></a>微服务应用架构</h3><p> <img src="ms.jpg" alt="微服务应用"><br>而9102谈微服务，自然离不开容器的影响。在单一功能边界清晰的一个个应用中，需要提供的不仅仅是服务的拉起与状态的监控，容器因其提供完备的网络层及高速的启停从而解决了复杂部署的痛点，从而使开发能更加专注于业务与实现。</p><h2 id="于运维"><a href="#于运维" class="headerlink" title="于运维"></a>于运维</h2><p>无论是应用承载量倒逼的服务拆分与分布式部署，还是梳理复杂业务进行逻辑清晰的应用边界划分而进行的架构迁移，在其中无可避免的都需要进行环境的迁移，而原生部署在linux主机上的应用可能存在：</p><ul><li>环境清洁未知: 历史服务卸载残留文件</li><li>端口划分及服务上下游环境完全依赖管理手段</li><li>迁移服务过程需要启停  </li></ul><p>我们需要的是容器！是一个个沙盒！是用完就删的快感！是点一个按钮就能做流控、做扩容伸缩、做版本升级！是一个页面掌控全部生产状态的Paas平台！</p><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><p>对于开发与运维的团队，渐渐的我们发现完全割离的组织架构及管理会给应用交付带来无尽的麻烦。软件的问题修复、应对市场添加的特性、整体优化及架构调整会带来无尽的版本发布任务并在这个过程中产生不可接受的沟通成本，而DevOps这一方法论其实更加符合敏捷软件的交付过程。<br>  <img src="devops.png" alt="两个队伍">  </p><p>这里我们发现，DevOps是<strong>方法论</strong>，必然是通过了软件交付的考验形成的集体认知与经验总结，我们知道，如果Ops成天抱怨研发大爷而对应用架构无所了解，Dev不考虑环境成本天马行空随性架构，那么我们很难对市场交付甚至带领项目走向终结。我们需要Dev和Ops之间合作沟通成为惯例，通过构建与自动化工具使软件更新与交付更加快速、频繁与稳定，具体来说，就是如何解放在软件交付和部署过程中的效率问题，一定要拎清的是这并不是具体指选用什么工具或组合而在会议室里大打出手，而是大家实践、沟通而产出的工作习惯与方法。</p><p>而今天我们说Docker对DevOps，自然也不是布道而已，我们更多的是想知道如何去管理运营这个团队并结合工具链从而有自己的思考。</p><h2 id="Docker于DevOps"><a href="#Docker于DevOps" class="headerlink" title="Docker于DevOps"></a>Docker于DevOps</h2><p>那么容器的加入到底为我们的研发与运维带来了什么呢？</p><h3 id="1-更好的隔离环境"><a href="#1-更好的隔离环境" class="headerlink" title="1. 更好的隔离环境"></a>1. 更好的隔离环境</h3><p>运维同志不用老是膈应研发大爷瞎用ubuntu，不懂任何线上linux环境调优一顿瞎用啦，让他自己写个Dockerfile乐意怎么弄怎么弄。</p><h3 id="2-随用随删"><a href="#2-随用随删" class="headerlink" title="2. 随用随删"></a>2. 随用随删</h3><p>单元测试完了集成测试来一发？或者直接写ut连上数据库？不用烦恼，写上pipeline一个job一个环境，一个service一个数据库。</p><h3 id="3-快速启停"><a href="#3-快速启停" class="headerlink" title="3. 快速启停"></a>3. 快速启停</h3><p>蓝绿发布用不起啊，50%的资源利用率，心疼啊！那怎么办？滚动发布啊，快速的容器启停配合容器集群工具实现服务持续可用的发布与升级。</p><h3 id="4-开箱即用的开源Paas平台"><a href="#4-开箱即用的开源Paas平台" class="headerlink" title="4. 开箱即用的开源Paas平台"></a>4. 开箱即用的开源Paas平台</h3><p>无论是kubernetes还是swarm都提供了容器管理及资源与服务监控，提供了可视化监控与页面运维，配合开源部署工具（jenkins/gitlab runner/github系列CI/CD工具）与git平台软件集成即可实现Paas平台的功能。</p><h2 id="践行"><a href="#践行" class="headerlink" title="践行"></a>践行</h2><p>我们生产中实现了以下工具链组成的CI/CD及Paas平台：</p><ul><li>基础的docker-ce</li><li>docker集群管理：kubernetes</li><li>kubernetes部署、管理与监控：rancher</li><li>代码管理及CI/CD：gitlab + gitlab runner<br>以上工具链配合相应的管理及权限分配进行了敏捷迭代的软件过程实践，具体内容我们再开篇幅细细展开。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.jjonline.cn/linux/238.html" target="_blank" rel="noopener">DevOps漫谈之一：DevOps、CI、CD都是什么鬼？</a><br><a href="https://www.nginx.com/learn/microservices/" target="_blank" rel="noopener">Understanding Microservices</a><br><a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway" target="_blank" rel="noopener">building microservices using an api gateway</a>    </p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写作与回顾</title>
      <link href="2019/08/06/%E5%86%99%E4%BD%9C%E4%B8%8E%E5%9B%9E%E9%A1%BE/"/>
      <url>2019/08/06/%E5%86%99%E4%BD%9C%E4%B8%8E%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>  开始于2016年的本科毕业阶段，字里行间都有着回忆和余韵。在青涩的文字与絮叨杂乱的思想抒发中仿佛技术干货才是附庸，这让在2019年回顾的我有些尴尬，所以这篇博客成了第一篇。</p> <a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>  之前的这里有的是絮絮叨叨，在今天看来大部分确是无病呻吟，咱们回顾一圈，打算将有用的技术记录重新整理再发出来，更多的谈些技术、思考与正面情感的记录。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
